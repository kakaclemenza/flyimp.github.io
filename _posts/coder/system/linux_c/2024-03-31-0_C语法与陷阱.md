---
layout: post
title: 0_C语法与陷阱
category: coder
typora-root-url: ../../../..
---



## 声明

本篇主要记录自己工作学习中使用C语言碰到的比较"刁钻"而又容易遗忘的问题, 并不系统介绍C语言, 因为没必要. 基于这个理由, 这里就简单的抄一个C语言知识框架, 做到心中有数即可:

**(一)二维数组初始化问题**

{% raw %}
可以省略第一维的定义，但不能省略第二维的定义。系统根据初始化的数据个数和第2维的长度可以确定第一维的长度。
　　`int a[][3]={ 1,2，3，4，5，6};`
　　a数组的第一维的定义被省略，初始化数据共6个，第二维的长度为3，即每行3个数，所以a数组的第一维是2。
　　一般，省略第一维的定义时，第一维的大小按如下规则确定：
　　初值个数能被第二维整除，所得的商就是第一维的大小；**若不能整除，则第一维的大小为商再加1**。例如，`int a[ ][3]={ 1,2，3，4};`等价于：`int a[2][3]={ 1,2，3，4};`
　　若分行初始化，也可以省略第一维的定义。下列的数组定义中有两对{ }，已经表示a数组有两行。
　　`static int a[ ][3]={ {1,2},{4}};`
{% endraw %}



**(二)localtime_r**

localtime会更改外部变量, 非线程安全, 而localtime_r则是线程安全的, 但是内部有加锁, 所以效率受到影响



**(三)位运算问题**

首先C语言中的与或非：

* 与: &是按位与，&&是逻辑与；
* 或: |是按位或，||是逻辑或；
* 非: ~是按位非，！是逻辑非；
* \>>n是右移n位；<<n是左移n位

```c
#include <stdio.h>

int main() {
	int a = 1, tmp = 1;
	a <<= 32;
	tmp <<= 31;
	tmp <<= 1;
	
	printf("a<<32: %d\n", a);		
	printf("tmp<<31, <<1: %d\n", tmp);
	printf("1<<32: %d\n", 1 << 32);
}

/*
输出如下:
a<<32: 1
tmp<<31, <<1: 0
1<<32: 0
*/
```

例子中, a和tmp是相同的变量, 只不过位移方式不太一样, 造成的结果是不一样的. 这个可以使用gcc -S将c编译成汇编, 可以看到实际使用的位移指令是`SAL`, 参看intel文档:

> Vol. 2B, section SAL/SAR/SHL/SHR—Shift: The count operand can be an immediate value or the CL register. The count is masked to 5 bits (or 6 bits if in 64-bit mode and REX.W is used). The count range is limited to 0 to 31 (or 63 if 64-bit mode and REX.W is used)

位移最大只有 2^5 - 1 = 31 位, 所以如果位移大于31, 则会和31进行与运算. `int a = 1; a<<32`结果就是`1<<(32 & 31) = 1<<0 = 1`

至于为什么使用`1<<32`输出的会是0, 这是由gcc编译器将c常量表达式编译成汇编时的处理. 把<u>常量表达式</u>的值求出来作为常量嵌在最终生成的代码中, 这种优化叫做**常量折叠**(constant folding)


