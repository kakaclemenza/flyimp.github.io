---
layout: post
title: 多进程与多线程
category: coder
typora-root-url: ../../..
---

### System V 进程通信方式：

System V 进程通信方式有: 信号量(semaphore)、消息队列(Message Queue)和共享内存(Share Memory)

**信号量**

信号量(semaphore)实际是一个整数，它的值由多个进程进行测试(test)和设置(set)。就每个进程所关心的测试和设置操作而言，这两个操作是不可中断的，或称“原子”操作，即一旦开始直到两个操作全部完成。测试和设置操作的结果是：信号量的当前值和设置值相加，其和或者是正或者为负。根据测试和设置操作的结果，一个进程可能必须睡眠，直到有另一个进程改变信号量的值。

信号量可用来实现所谓的“临界区”的互斥使用，临界区指同一时刻只能有一个进程执行其中代码的代码段。为了进一步理解信号量的使用，下面我们举例说明。

假设你有很多相互协作的进程，它们正在读或写一个数据文件中的记录。你可能希望严格协调对这个文件的存取，于是你使用初始值为1的信号量，在这个信号量上实施两个操作，首先测试并且给信号量的值减1，然后测试并给信号量的值加1。当第一个进程存取文件时，它把信号量的值减1，并获得成功，信号量的值现在变为0，这个进程可以继续执行并存取数据文件。但是，如果另外一个进程也希望存取这个文件，那么它也把信号量的值减1，结果是不能存取这个文件，因为信号量的值变为-1。这个进程将被挂起，直到第一个进程完成对数据文件的存取。当第一个进程完成对数据文件的存取，它将增加信号量的值，使它重新变为1，现在，等待的进程被唤醒，它对信号量的减1操作将获得成功。

 

**消息队列**

消息队列也称为报文队列，消息队列是随内核持续的，只有在内核重起或显示删除一个消息队列时，该消息队列才会真正删除 系统中记录消息队列的数据结构struct ipc_ids msg_ids位于内核中，系统中所有消息队列都可以在结构msg_ids中找到访问入口

消息队列其实就是一个消息的链表，每个消息队列有一个队列头，称为struct msg_queue，这个队列头描述了消息队列的key值，用户ID，组ID等信息，但它存于内核中而结构体struct msqid_ds能够返回或设置消息队列的信息，这个结构体位于用户空间中，与msg_queue结构相似消息队列允许一个或多个进程向它写入或读取消息，消息队列是消息的链表。

消息是按消息类型访问，进程必须指定消息类型来读取消息，同样，当向消息队列中写入消息时也必须给出消息的类型，如果读队列使用的消息类型为0，则读取队列中的第一条消息。

内核空间的结构体msg_queue描述了对应key值消息队列的情况，而对应于用户空间的msqid_ds这个结构体，因此，可以操作msgid_ds这个结构体来操作消息队列。

 

**共享内存**

共享内存是运行在同一台机器上的进程间通信最快的方式，因为数据不需要在不同的进程间复制。通常由一个进程创建一块共享内存区，其余进程对这块内存区进行读写。共享内存往往与其它通信机制，如信号量结合使用，来达到进程间的同步及互斥。



### 线程间互斥

生产者和消费者使用互斥锁和条件变量通信

- 在单个进程中创建多个线程，分为生产者线程和消费者线程，生产者和消费者使用同一块内存区。
- 生产者向内存区写入数据，同时修改head和tail，消费者从内存区读取数据，也修改head和tail。
- 对于内存区不允许消费者和生产者同时访问，因此使用pthread_mutex_t进行互斥锁保护。
- 生产者使用pthread_cond_broadcast唤醒调用了pthread_cond_wait的消费者，这里需要注意pthread_cond_wait会自动释放锁，无需再次释放。

### 进程间互斥

共享内存和信号量的使用有以下几点需要注意

- 无论是共享内存还是信号量，创建与初始化都遵循同样流程，通过ftok得到key，通过xxxget创建对象并生成id；
- 生产者和消费者都通过shmat将共享内存映射到各自的内存空间，在不同的进程里面映射的位置不同；
- 为了访问共享内存，需要信号量进行保护，信号量需要通过semctl初始化为某个值；
- 接下来生产者和消费者要通过semop(-1)来竞争信号量，如果生产者抢到信号量则写入，然后通过
- semop(+1)释放信号量，如果消费者抢到信号量则读出，然后通过semop(+1)释放信号量；
- 共享内存使用完毕，可以通过shmdt来解除映射。



### 死锁

\1. 死锁产生必要条件：

- 资源互斥：进程对所分配到的资源进行排他性使用，即在一段时间内某个资源只能由一个进程占用
- 请求和保持：进程在持有资源不释放的情况下继续申请其他互斥资源
- 不剥夺：持有互斥资源的进程在完成之前不被其他进程剥夺，资源仅由本进程完成后释放
- 循环等待：多个进程间互相持有其他进程的资源，任何进程都无法进步一获得资源

\2. 死锁预防--破坏必要条件：

- 允许资源共享，但适合场景有限
- 采用静态分配方式，进程执行前先申请全部所需资源，都满足后才开始执行
- 1)申请新资源时必须释放已有资源；2)允许资源分配程序剥夺申请资源进程的已有资源
- 采用编号分配策略，资源申请必须按照编号依次进行，避免循环等待

\3. 死锁避免：

- 银行家算法

\4. 死锁检测：

- 从一个节点出发进行深度优先搜索，标记已访问过的节点，判断有环路即已发生死锁

\5. 死锁恢复：

- 资源剥夺，使进程休眠
- 恢复检查点并回退进程，直至处于安全状态
- 撤销死锁进程，回收并重新分配资源



### Linux 多线程环境下 线程joinable状态和unjoinable状态

这里主要讨论这两种状态下，线程终止以及资源释放的问题

linux线程中，pthread有两种状态**joinable状态**和**unjoinable状态**。

**joinable**状态下，当线程函数**自己返回退出时或pthread_exit时**都不会释放线程所占用堆栈和线程描述符。只有当你调用**了pthread_join之后**这些资源才会被释放，这是需要main函数或者其他线程去调用pthread_join函数。

**unjoinable**状态的线程，这些资源在**线程函数退出时或pthread_exit**时自动会被释放。设置unjoinable状态设置有两种办法 一是可以**在pthread_create时指定**，二是线程创建后在线程中**pthread_detach自己 pthread_detach(pthread_self())，**状态改为unjoinable状态，确保资源的释放



### 信号

每种信号类型都有对应的信号处理程序(也叫信号的操作)，就好像每个中断都有一个中断服务例程一样。大多数信号的默认操作是结束接收信号的进程；然而，一个进程通常可以请求系统采取某些代替的操作，各种代替操作是：

- 忽略信号SIG_IGN。随着这一选项的设置，进程将忽略信号的出现。有两个信号  不可以被忽略：SIGKILL，它将结束进程；SIGSTOP，它是作业控制机制的一部分，将挂起作业的执行。
- 恢复信号的默认操作。
- 执行一个预先安排的信号处理函数。进程可以登记特殊的信号处理函数。当进程收到信号时，信号处理函数将像中断服务例程一样被调用，当从该信号处理函数返回时，控制被返回给主程序，并且继续正常执行。

但是，信号和中断有所不同。中断的响应和处理都发生在内核空间，而信号的响应发生在内核空间，信号处理程序的执行却发生在用户空间。

那么，什么时候检测和响应信号呢？通常发生在两种情况下：

- 当前进程由于系统调用、中断或异常而进入内核空间以后，从内核空间返回到用户空间前夕；
- 当前进程在内核中进入睡眠以后刚被唤醒的时候，由于检测到信号的存在而提前返回到用户空间。

函数原型等详见：<http://www.cnblogs.com/biyeymyhjob/archive/2012/08/04/2622265.html>



是否存在SIGSTOP和SIGKILL也无法终止的进程?

存在! 以下两种情况下SIGSTOP和SIGKILL不起作用:

* 该进程处于”Zombie”状态
* 该进程处于”kernel mode”(核心态)且在等待不可获得的资源. 处于核心态的进程忽略所有信号处理

**信号本质**

信号是在软件层次上对中断机制的一种模拟，在原理上，一个进程收到一个信号与处理器收到一个中断请求可以说是一样的。信号是异步的，一个进程不必通过任何操作来等待信号的到达，事实上，进程也不知道信号到底什么时候到达。

信号是进程间通信机制中唯一的异步通信机制，可以看作是异步通知，通知接收信号的进程有哪些事情发生了。信号机制经过POSIX实时扩展后，功能更加强大，除了基本通知功能外，还可以传递附加信息。

**信号来源**

信号事件的发生有两个来源：硬件来源(比如我们按下了键盘或者其它硬件故障)；软件来源，最常用发送信号的系统函数是kill, raise, alarm和setitimer以及sigqueue函数，软件来源还包括一些非法运算等操作。