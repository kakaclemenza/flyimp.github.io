---
typora-root-url: ../../../
---





注意: 这里只对实现具体功能的函数名做列出, 具体函数如何实现:

* 主要参考man手册页
* 样例参考apr: 提供了常用系统编程接口的封装, 而且是支持多个类型操作系统. 链接: https://apr.apache.org/



### 文件系统类型及其内部原理

文件系统中包括的文件类型有:

* 文件:
* 目录: 
* 软链接: 是一个文件, 有单独的inode, 文件内容是其链接的文件的路径
* 硬链接: 
* 设备文件: 



### 文件描述符

文件描述符在linux中对应一个内部的file结构. 在用户层指代了一个打开的文件对象.

文件描述符是归属于某个进程的, 一个进程能打开的文件描述符个数有限制, 用`ulimit -n`查看.

系统保留的文件描述符, 定义在<unistd.h>中, 分别为: 0(STDIN_FILENO), 1(STDOUT_FILENO), 2(STDERR_FILENO).

##### 提问:

* 可否加大进程能打开的文件描述符
* 进程能打开最多的文件个数, 进程能打开最多的socket个数?

### 文件归属和权限

* 新文件的owner是创建文件的那个进程的有效uid;
* 新文件的group, System V采用创建文件的进程的有效gid, 但BSD采用文件父目录的组ID, linux默认使用的BSD方式
* 新文件的权限
  * open指定O_CREAT: 本次打开的文件操作并不受该权限影响; 文件权限 = `mode & ~umask`; 注意manual中说明O_CREAT必须指定mode, 未指定的话文件权限时随机不确定的



### 不带缓存IO

不带缓存IO就是使用Linux系统调用的IO, 包括open(), read(), write(), lseek(), close()等, 这些不带缓存的IO函数不是ANSI C的组成部分, 而是POSIX组成部分. 

* open(): 有两个声明, 第二个声明中的mode参数只在创建文件时使用, mode 参数并不会限制当前创建文件的这个 open 调用.
* creat(): 等效于open(pathname, O_WRONLY | O_CREAT | O_TRUNC, mode)
* close(): 
  * 进程终止时, 内核会自动关闭它打开的所有文件. 不过最好显式关闭
  * 关闭文件并不会确保文件数据已经写入到磁盘. 最好加上同步IO
  * 文件从磁盘中被删除, 但只要它还有引用计数, 文件不会被真正物理删除
* access(): 检查是否有操作文件的某个权限
* read(): 读. 
  * 读磁盘文件, 超过文件所含字节数则只返回到文件末尾的字节数, 下次再读返回0
  * 读终端设备文件, 以行为单位, 读到换行符就返回
  * 读磁带, 依次最多返回一个记录
* write(): 写; 实际是内核写入缓冲区, 再延迟写磁盘, 导致: (1)读写性能提高; (2)写入顺序由内核控制; (3)写入的缓冲区和进程无关联, 刷盘错误无法报告给进程
* fsync(fd)/fdatasync(fd): 确保文件描述符 fd 指向的文件相关联的所有数据都被写入磁盘  
* sync(): 同步所有缓冲区的数据到磁盘中  
* seek()/lseek(): 调整文件操作指针; seek可以越过文件末尾, 读返回EOF, 写造成文件"洞"(文件系统支持, 导致"稀疏文件", 占用空间比实际磁盘空间大)
* truncate()/ftruncate(): 截短文件长度
* utime(): 调整文件的访问和修改时间
* stat()/fstat(): 获取文件信息; 或这获取目录信息(一切皆文件)
* lstat(): 获取软链接信息
* unlink(): 删除文件 !!!



### 带缓存的IO

带缓存的IO, 

例子: fopen() -> fputs() -> freopen() -> fgets() -> fclose()

**注意**:

1. 多进程同时使用带缓存IO方式访问同一个文件: 



### dup和dup2

```c
#include <unistd.h>

int dup(int oldfd);
int dup2(int oldfd, int newfd);
```

两者作用都是将两个文件描述符指向同一个文件描述结构(共享文件偏移, 文件标志), 区别是dup()是新建一个最小可用的文件描述符, 而dup2()指定一个已存在的文件描述符.

调用`dup`族类函数得到的新文件描述符**将清除`O_CLOEXEC`标志**

### 进程和打开的文件: dup原理, 多进程打开同一文件, 单进程多次打开文件

Linux的进程描述结构体`task_struct{}`中有一个**文件描述符表**数组专门用于记录一打开的文件, 其中文件描述符作为该数组的下标, 数组元素为指向所打开的文件所创建的**文件表项**. 如下图所示，文件表项是用于描述文件当前被某个进程打开后的状态信息, 包括:

* 文件状态标志
* 当前文件读取的位移量（可以通过接口lseek设置）
* 文件的i节点指针（i节点描述文件的具体信息，如：创建，修改时间，文件大小，文件存储的块信息)

不同场景下, 进程打开文件所对应的进程文件描述符表->文件表项->v节点项的对应关系是不同的, 这也导致它们有不同的行为

#### 无亲缘关系进程打开同一个文件

![image-20220329171842493](/img/coder/system/multiprocess_open_same_file.png)

特性: 文件偏移量不同, 两个进程如果同时写该文件, 会导致A进程写的内容被B进程覆盖. 解决方法有:

* 使用`O_APPEND`, 由操作系统确保每次写操作系统调用都是再文件末尾执行. 又因为系统调用都具有原子性, **推荐**!
* 使用信号量互斥, 并在每次持有信号量后, 使用`lseek(fd, 0, SEEK_END)`定位到文件尾部, 这样显得比较复杂.
* 使用文件锁: 使用`flock(fd, LOCK_EX)`排他锁检查并进入互斥区, 然后同样需要使用lseek定位到文件尾部再写入, 这样也是比较复杂.

#### fork()父子进程打开同一文件

![image-20220329172830364](/img/coder/system/forkprocess_open_same_file.png)

特性: 父子进程共用同一个文件表项, 共享相同的文件偏移量, 读写不会有异常问题.

#### 同一进程多次打开同一文件

![image-20220329185803694](/img/coder/system/process_open_multiple_file.png)

特性: 每打开一个文件, 对应一个新的文件表项, 两个表项的文件偏移量相互独立, 所以操作文件的时候也要注意便宜问题. 不过由于在同一个进程中, 没有互斥问题.

#### 进程中使用dup, dup2

![image-20220329190011024](/img/coder/system/process_dup_file.png)

特性: 文件描述符不同, 其他相同

### 文件标志

#### O_CLOEXEC

`O_CLOEXEC`模式打开的文件描述符在执行`exec`调用新程序中关闭, 且为原子操作. 

注意:

* 在通过`fork`调用产生的子进程中不会关闭`O_CLOEXEC`模式打开的文件描述符
* 调用`dup`族类函数得到的新文件描述符将清除`O_CLOEXEC`模式

#### O_CREAT + O_EXCL

O_EXCL确保系统调用创建了具体的文件, 如果文件已经存在则返回错误EEXIST; O_EXCL只能和O_CREAT一起使用, 否则O_EXCL的行为是未定义的. 

#### O_ACCMODE, O_RDONLY, O_WRONLY, O_RDWR

- O_ACCMODE<0003>：读写文件操作时，用于取出flag的低2位
- O_RDONLY<00>：只读打开
- O_WRONLY<01>：只写打开
- O_RDWR<02>：读写打开

#### O_NONBLOCK

非阻塞操作

#### O_SYNC / O_DSYNC / O_RSYNC

传递给 open()调用, 表示当前文件上的所有 I/O 操作都应该被同步; read()总是同步的, 这个选项主要限制write()也执行同步IO, 即: 在每一个 write()操作之后, 都立即强制执行一个隐式的 fsync()调用

#### O_DIRECT

open()时提供 O_DIRECT 标志，指示内核最小化 I/O 管理的存在。当使用这个标志时， I/O将直接从用户空间缓冲区向设备发起，绕过页面缓存。所有 I/O 都是同步的，操作没有完成前不会返回。
当执行直接 I/O 时，操作的请求长度、缓冲区、文件偏移量都必须是底层设备扇区大小的整数倍——通常是 512 字节。  



### 多进程同时访问文件资源: O_APPEND

   当 fd 以附加模式（O_APPEND）打开时， write 操作不会在文件描述符的当前文件位置进行，而总是在文件的当前结尾位置进行写入。
    例如，假设两个进程向同一个文件写入数据。如果不使用附加模式，当第一个进程在文件末尾写入数据，然后第二个进程执行同样的操作。这时候第一个进程的文件位置就不再指向文件的末尾，它指向的是文件的实际末尾减去第二个进程写入的数据数。这就意味着多个进程不允许在没有显式的同步操作下，向同一个文件添加数据，这里存在竞争条件。
    附加模式避免了这个问题，它确保文件位置总是设置为文件的末尾，这样所有的写入操作都是附加，即使是多个写入操作。你可以把它想象成每次写入操作之前，都有一个原子的文件位置更新操作。文件位置自动被设置为新写入数据的末尾处，这不会影响到下一次write()调用，但可能会影响你下一次的读取操作。
    附加模式对某些特定的任务有很大的意义，**例如更新日志文件**；但对于很多其它任务来说，又是不合适的  



### 链接

* link(): 创建硬链接
* lstat(): 获取软链接信息
* symlink(): 创建软链接
* unlink(): 对于软链接会删除软链接; 对于硬链接则删除硬链接, 如果指向最后一个硬链接, 就是删除该文件; **注意**: 只要文件还被其他进程持有文件描述符计数, 则文件在内核中就是没有被删除的, 知道计数为零才真正删除



### 目录

* getwd(): 获取当前工作目录
* chdir(): 改变工作目录
* mkdir(): 新建目录
* rmdir(): 删除目录
* opendir(): 【库函数】打开目录, 返回`DIR*`
* stat(): 查看目录状态
* readdir(): 【库函数】读取目录中的下一项, 返回`struct dirent *`包括目录中某项的信息



## 关联问题

linux下一切皆文件, 所以熟悉文件的操作细节对于linux系统管理和开发而言十分重要. 自然这一点也被各种面试问道. 以下收集和文件相关的细节问题, 并结合我对于linux操作系统原理的理解做深入分析

### 系统磁盘空间占用过高怎么查找原因

1. 使用df定位到具体分区, 使用du定位到具体文件.
2. 文件无法删除
   这里注意明确一点, **在linux下不会有文件因为被进程占用而无法删除的**. 进程打开文件实际上只是在内核中增加了文件系统中该文件的引用计数.
   那么文件无法删除只能是权限相关的问题, 主要有基础属性(ls -l查看, rwx)和隐藏属性(lsattr查看). 有时文件无法被删除还可能是文件所在文件夹被设置了不可删除属性.
3. 如果du无法定位到具体文件, 则可能是文件已经被删除, 但是有进程打开着该文件
   Linux下的文件，只有在引用数为0的情况下才会真正被删除掉，之前所占用的空间是不会被释放的。 如果存在文件引用，系统会将该文件标记为已删除，在引用此文件的进程都关闭时（文件引用数为0时），最终删除文件，释放空间资源。
   可以通过**`lsof -n | grep deleted`**的"SIZE/OFF"一列定位到已被删除的大文件文件, 杀掉对应的进程, 空间自然能被释放

另外第二点引申下, 如果文件被不小心删掉了, 可以通过查找是否有相关的进程占用该文件, 通过该进程复原文件. 具体方法如下:

```shell
lsof | grep data.file1		# 得到该文件的文件描述符, 比如是10, 进程号15210
cp /proc/15210/fd/10 > /dir/data.file1
```

但是如果已经找不到进程占用, 则该文件已经确实被从磁盘删除了, 此时只能利用磁盘文件恢复软件, 如extundelete, debugfs

### io复用: epoll, kqueue, 



### 跨平台IO复用: Select

select在不同平台下的实现是不同的, 这会带来一些奇怪的问题, 如: 当打开文件较多时, 此时再建立socket链接托给select管理:

* linux或ios(unix): 出现内存越界导致崩溃
* windows: 正常服务

这里原因是linux或unix的select在添加监听的文件描述符时, FD_SET()宏会对内核分配的数组写越界修改到后续的变量, 后续访问被修改的变量就会报段错误.

实际linux或unix内核并没有对select监听的文件描述符数量做限制, 我们只需另外分配fd_set结构体的内存到足够大的堆上就行. dog250就给出了这个测试实现: https://blog.csdn.net/dog250/article/details/105896693

至于为啥windows能正常服务, 因为windows的select使用来记录文件描述符的数组是"字节图"而不是"位图". 按照实验现象, windows默认最多只监听64个文件描述符. 超过了, 虽然不会报错越界, 但是设置不上去. 若想拓展, 需要改宏定义的, 参考: https://docs.microsoft.com/en-us/windows/win32/api/winsock2/nf-winsock2-select



### mmap(): 内存映射文件



### 文件锁: flock, lockf, fcntl

注意点: 

* 强制锁和建议锁: 三者都可以实现建议锁, 但只有fcntl可以实现强制性锁;
* 文件锁和记录锁: flock只能实现对整个文件上锁, 即文件锁; lockf和fcntl可以实现记录锁.
* lockf只是对fcntl的一个封装

flock和fcntl另一个重要的差别是: 它们实现锁的方式不同

* 使用lockf或fcntl的锁，在实现上**关联到进程结构体**，这样的实现导致锁不会在fork之后被子进程继承

* flock在实现上**关联到的是文件表项**, 从上文我们知道fork()出的子进程中或是在dup()后的新描述符都是指向相同的文件表项, 所以它们都会持有相同的文件锁, 对该文件加互斥锁会成功, 体现为修改锁类型操作!!!

  同样在解除flock文件锁时, 如果子进程使用close(fd)关闭了文件, 只是减了一个到文件表项的引用计数, 并没有释放文件, 文件锁也就不会释放. 下文有具体分析.

* exec只是使用新的进程体替代掉旧进程, 旧进程打开的文件描述符, 持有的文件锁无论是flock还是fcntl都是会保持的, 除非使用了`close-on-exec`标记

文件锁的解除

* 用 LOCK_UN 解锁

  文件锁的解除可以通过将 flock 的 operation 参数设置为 LOCK_UN 常量来实现。这时如果有多个fd 指向同一文件表项，例如给 fd0 加文件锁后，用 dup 复制了fd0 的情况下，用 LOCK_UN 对fd0 解锁后，所有和 fd0 指向同一文件表项的 fd 都不再持有文件锁。fork 子进程复制父进程文件描述符的情形也是如此。

* 关闭文件时自动解解锁

  对描述符fd加了文件锁后，如果没有显式使用LOCK_UN 解锁，在关闭 fd 时，会自动解除其持有的文件锁。但是在为 fd 加锁后如果调用 了dup 复制了文件描述符，这时关闭fd 时的表现和调用 LOCK_UN 是不一样的。

  如果未显式使用 LOCK_UN 解锁，在关闭文件描述符后，如果还有其他的fd 指向同一文件表项，比如之前调用了dup 的情形，这时加在文件表项上的文件锁并不会解除，其他指向此文件表项的文件描述符依然持有锁，并且锁的类型也不会发生变化。

  使用fork 产生子进程时同样如此。父进程和子进程的描述符指向同一文件表项且已经加了文件锁时，如果用 LOCK_UN 将其中一个fd 解锁，那么指向同一表项的所有其他fd 都会自动解锁。但是如果未使用 LOCK_UN 解锁，只是通过 close(fd) 关闭了某个文件描述符，那么指向同一文件表项的其他描述符，依然会持有原有的锁。

  出于方便考虑，在没有出现多个fd 指向现一文件表项的情况下，可以直接使用close(fd) 的默认解锁功能，而不用显式的使用LOCK_UN。在有多个 fd 指向同一文件表项的情形下，如果要完全解锁，一定要使用 LOCK_UN 解锁，不能再使用 close(fd) 的默认解锁功能。

