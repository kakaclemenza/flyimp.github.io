---
layout: post
title: StarUML设计
category: coder
---

### StarUML 安装

直接官网下载.deb, 本地安装即可

### UML 图与设计模式的关系
* UML 图是为面向对象开发系统的产品进行说明、可视化、和编制文档的一种标准语言 .

  UML基本的构造块：事物、关系和图

  UML事物是对模型中最具有代表性的成分的抽象，包括结构事物，如:类(Class)、接口(Interface)等

  UML关系用来把事物结合在一起，包括:依赖、关联、泛化和实现关系

  UML 图主要通过使用**3种**就可以明确需求(用例图), 实现交互过程(时序图), 类的具体内容(类图)

* 设计模式: 是一套帮助设计 UML 图的经验总结.   

### UML类图关系

* 泛化(Generalization)

  就是继承关系, 子类继承父类

  **箭头指向**：带三角箭头的实线，箭头指向父类

* 实现(Realization)

  就是类与接口的关系, 表示类是接口所有特征和行为的实现.
  **箭头指向**：带三角箭头的虚线，箭头指向接口

* 依赖(Dependency)

  是一种使用的关系，即一个类的实现需要另一个类的协助，所以要尽量不使用双向的互相依赖.
  **代码表现**：局部变量、方法的参数或者对静态方法的调用
  **箭头及指向**：带箭头的虚线，指向被使用者

* 关联(Association)

  是一种拥有的关系 ,它使一个类知道另一个类的属性和方法

  **代码体现**：成员变量
  **箭头及指向**：带普通箭头的实心线, 双向的关联可以有两个箭头或者没有箭头, 单向的关联有一个箭头, 指向被拥有者

  * 聚合(Aggregation)

    聚合是整体与部分的关系，且部分可以离开整体而单独存在。如车和轮胎是整体和部分的关系，轮胎离开车仍然可以存在。

    聚合关系是关联关系的一种，是强的关联关系；关联和聚合在语法上无法区分，必须考察具体的逻辑关系。
    **代码体现**：成员变量
    **箭头及指向**：带空心菱形的实心线，菱形指向整体

  * 组合(Composition)

    是整体与部分的关系，但部分不能离开整体而单独存在。如头和嘴巴是整体和部分的关系，头不存在了, 嘴巴就肯定没有了。
    组合关系是关联关系的一种，是比聚合关系还要强的关系，它要求普通的聚合关系中代表整体的对象负责代表部分的对象的生命周期。
    **代码体现**：成员变量
    **箭头及指向**：带实心菱形的实线，菱形指向整体

  关联, 聚合, 组合三种关系无法通过代码体现进行区分, 只能通过代码目的进行分辨.

### C++中设计模式的应用

#### 设计模式大纲

```shell
创建型
├── 简单工厂: 创造对象
├── 工厂方法: 可以按具体方法创造对象
├── 抽象工厂: 可以按不同关联的方法创造对象
├── 生成器
├── 原型
└── 单例
结构型
├── 适配器: 加一层
├── 桥接: 组合同类别操作, 减一层
├── 组成
├── 装饰
├── 外观
├── 享元
└── 代理
行为型
├── 责任链
├── 命令
├── 迭代器
├── 中介者
├── 备忘录
├── 观察者: 发布-订阅模式
├── 访问者: 方便对象迭代时, 使用相同的方法, 但是
├── 策略
├── 状态
└── 模板方法
```

ref: https://segmentfault.com/a/1190000010706695#item-3-9

#### 单例模式

```C++
class Singleton{
private:
	Singleton() { };
	~Singleton() { };
	Singleton(const Singleton&);
	Singleton& operator=(const Singleton&);
public:
	static Singleton& getInstance() {
		static Singleton instance;
		return instance;
	}
};
```

C++11下, 编译器保证了内部静态变量的线程安全性. 即当有一个线程执行static类对象的构造函数时，其他欲访问该static类对象的线程都是阻塞的



#### 总结

说起来 23 种设计模式, 很吓人的样子, 其实应该重点掌握的只有几个而已:

- 创建型模式中, 重点掌握**三个工厂, 与单例**. 简单工厂实际上算不上模式(书里都没单独列出), 关键就是工厂方法, 抽象工厂只不过是工厂的工厂而已. 那么工厂方法其实抽象的是`new`的过程, 那么关键就是 `new` 的两边都应该是抽象接口, 封装掉具体实现. 单例模式, 要先了解其弊端, 但那也是它最核心的特点: 全局性. 这玩意会在实际开发中大量使用, 但理想情况下应该是避免的. 剩下俩: 原型就是 copy, 生成器就是"拆迁构造器".
- 结构型模式中, 重点掌握**桥接**, 这个模式是重构神器. 如果领导说, 这个类太复杂了, 把它"抽一抽", "单拎出来". 那么十有八九是运用桥接模式. 结构型其实可以按以下基本特性分个类:
  - **加**一层: 适配器, 外观, 代理
  - **减**肥: 桥接
  - 常见编程技巧: 组合(就是基于接口迭代), 享元(哈希表), 装饰(不断实例化修改父类成员)
- 行为型模式中, 重点掌握**观察者**和**访问者**. 行为型模式都有一个共同的特点, 就是非常讲究**注入**和**回调**这两个手段. 尤其以观察者与访问者, 用的登峰造极. 前者是所有消息系统的灵魂, 重点掌握消息列表, 与通知的时机. 后者是著名的**IoC(控制反转)**与**DI(依赖注入)**的灵魂. 这也是维护老系统必备的技巧. 它的重点是在**不破坏已有接口**的前提下, 如何增加新的特性. 剩下的模式我们也大致分个类:
  - 基本数据结构在面向对象的体现: 责任链(对象链表轮询), 命令(ACID), 迭代器(C++ 中的 iterator), 备忘录(缓存状态), 状态(状态机)
  - DI: 中介者(注入中介), 观察者(注入订阅者), 访问者(注入访问接口), 策略(注入算法对象)
  - 常见编程技巧: 模板方法(固定接口, 子类实现)

Tips: 不同大类的模式, 也许名字听着类似, 但实质却完全不同. 如中介者, 与适配器, 代理, 感觉就很类似. 但中介者是被**注入**后起到作用的, 后两者却是**在结构上**增加了一层.

划出的几个重点也是面试常常考察的: 工厂, 单例, 桥接, 观察者, 访问者. 其余要么过于简单, 没啥好考察的; 要么已经和语言特性密不可分, 问起来容易被绕过去. 但这五者, 却很具备考察性, 要是能数清楚, 设计模式就算掌握了.

