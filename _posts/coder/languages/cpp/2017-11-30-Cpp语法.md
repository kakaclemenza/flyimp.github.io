---
layout: post
title: Cpp语法
category: coder
---

### Description
记录一些比较特殊的容易忘记的 cpp 语法
* ::name   
::是运算符中等级最高的，它分为三种:  
1)global scope(全局作用域符），用法（::name)  
2)class scope(类作用域符），用法(class::name)  
3)namespace scope(命名空间作用域符），用法(namespace::name)  
他们都是左关联（left-associativity)  
他们的作用都是为了更明确的调用你想要的变量，如在程序中的某一处你想调用全局变量a，那么就写成::a，如果想调用class A中的成员变量a，那么就写成A::a,另外一个如果想调用namespace std中的cout成员，你就写成std::cout（相当于using namespace std；cout）意思是在这里我想用cout对象是命名空间std中的cout（即就是标准库里边的cout）  
他们算是C++中的基础，如果运用的好的话，你程序的出错率也许会降很多，  

* 测试系统  
* 时间系统  
* 事件循环  

### 值语义 与 对象语义
值语义: 对象拷贝后与原对象无关, 相当与对象的深拷贝. C++内置类型都是值语义(string, vector, map也是值语义)
对象语义: 指面向对象意义下的对象.
​	1. 对象拷贝是禁止的
​	2. 允许对象拷贝. 但是拷贝后两对象间共享底层资源, 对任何一个的改变都将改变另一个

基于对象编程: 值语义. 通常以类对象的方式使用
面向对象编程: 对象语义. 通常以指针或者引用方式使用

对象语义通常使用智能指针. RAII技术, 资源获取即初始化
auto_ptr			所有权独占, 不能共享, 但是可以转移
shared_ptr			所有权共享, 内部维护引用计数
weak_ptr			与shared_ptr配合使用 循环引用
scoped_ptr			所有权独占, 不能共享, 不可转移

### 分析 Calculator 中哪些类应该是什么语义
```cpp
Node n1;
Node n2(n1);
```
浅拷贝:
当n1销毁的时候, 会去释放他的子代
当n2销毁的时候, 也会重复释放, 导致错误

### 接口继承 与 实现继承
接口继承: public继承, 继承之后子类的对象可以使用父类的接口
实现继承: protected或private继承, 只是继承了父类实现的功能, 子类的对象不可以使用父类的接口.

### 对象间关系
依赖关系: 类A作为类B的构造参数
组合关系: 类A使用了类B的值语义, 类A负责类B的生命周期
关联关系: 弱关系, 类A不负责类B的生命周期

### 继承和组合的取舍

继承: 是`is-a`关系时

组合: 是`has-a`关系

### 多重继承

在现实生活中，一些新事物往往会拥有两个或者两个以上事物的属性，为了解决这个问题，C++引入了多重继承的概念，C++允许为一个派生类指定多个基类，这样的继承结构被称做多重继承。（派生类有两个或两个以上的直接基类）使用多重继承时要十分小心，经常会出现二义性问题

#### 多重继承的二义性: 菱形继承

```cpp
class BC0
{
public:
    int K;
};
class BC1 : public BC0
{
public:
    int x;
};
class BC2 : public BC0
{
public:
    int x;
};
class DC : public BC1, public BC2
{
};
void main( )
{ 
    d.x = 1;       // error C2385: 对"x"的访问不明确
         //可能是"x"(位于基"BC1"中)，也可能是"x"(位于基"BC2"中)
    d.BC1::x = 2;   // OK，from BC1
    d.BC2::x = 3;   // OK，from BC2
    d.K = 4;           // error C2385: 对"K"的访问不明确
    d.BC1::K = 5;  // OK，from BC1
    d.BC2::K = 6;  // OK，from BC2
    d.K = 13;    // OK
}
```

解决: 

1. 解决BC1, BC2的x访问问题: 只能通过`d.BC1::x`的方式指定访问哪个基类
2. 解决BC0的K的访问: BC1, BC2使用`virtual public`虚继承, 这样c++能确保公共继承对象在创建时只保存一分实例

#### 多重继承下的构造函数构造顺序

- 单继承派生类构造时，首先构造基类，其次是派生类的数据成员的初始化（顺序和派生类数据成员的声明顺序相同），最后执行派生类的构造函数体。
- 多继承派生类构造时，**首先构造虚基类**，多个虚基类**按照他们被继承的顺序**依次构造，**其次构造一般基类**，多个一般基类按照被继承的顺序构造，然后初始化派生类的数据成员。
- 初始化派生类的数据成员，初始化顺序和派生类数据成员的声明顺序相同，最后执行派生类的构造函数体。

### cpp 返回引用或指针的问题探究



### const 和 constexpr 

const修饰的是类型，constexpr修饰的是用来算出值的那段代码。   constexpr修饰的函数，简单的来说，如果其传入的参数可以在编译时期计算出来，那么这个函数就会产生编译时期的值。但是，传入的参数如果不能在编译时期计算出来，那么constexpr修饰的函数就和**普通函数**一样了