---
layout: post
title: C++基础
category: coder
---

## ============= 基础理论 ===============

### 程序设计技术

#### SP(Structure Programming)技术
> 1)程序语言只包括顺序、选择、循环三种控制结构，其目标是使程序的 各个局部符合控制的单入口单出口原则。
> 2)努力规范和简化模块之间的联系，充分利用过程或函数的参数机制， 规范程序模块间的接口。严格区分数据类型，所有程序中出现的数据都必须进行类型说明和任何 数据操作都进行类型检查。

#### OOP(Object Oriented Programming)技术
> &emsp;  大量的程序设计任务，已经导致人们不得不探索新的更可靠更高效的设计开发技术。 OOP 方法正是在这样的形势下，成为**唯一可行的选择**(? 真的吗 ?)。   
> &emsp;  OOP 技术之所以能适应今天软件产业的需要，是因为它比较好地解决了软 件模块化、信息隐蔽和抽象的目标。通过类和对象，把程序所涉及的数据结构 和对它施行的操作有机地组成模块，对于数据和对数据的处理细节进行了最大 限度的封装，其密封性、独立性和接口的清晰性都得到了加强。
> &emsp;  java 语言也是 OOP 语言, 它开始是用来设计 Internet 上的浏览器

### 程序设计范型(programming paradigms)
- 命令型程序设计
- 面向对象程序设计
- **函数型程序设计**
- 逻辑型程序设计

### 程序设计技术的四个层次
* 算法   
&emsp;  算法理论是整个计算机科学的核心。一个高级程序员必须掌握有关算法设计与分析的知识，否则他不会编出高水平、高质量的程序，更不要说有创造性的程序了
* 程序设计方法   
&emsp;  `软件工程`技术
* 程序设计语言
* 程序设计环境与工具

### 算法

* 算法设计过程是逐步求精的
* 常使用流程图或伪代码描述算法

### 数据与数据结构

数据: 程序操作的对象

数据结构: 数据对象之间的相互关系及构造方法

与算法关系: 数据结构有其配套的方法




## 表达式计算器(compiler小项目)
### 五. 更正测试上的缺陷
* 8-2+1 = 5 , 这是因为采用的是右结合
避免方法是使用左结合, 但是根据代码左结合会导致无限循环. 这个要么根据编译原理进行改进. 或者用一个小技巧, 将符号和数字进行结合. 

* MultipleNode 抽象类
=> 支持多元运算, 解决上面的右递归问题.

### 六. 符号表SymbolTable
* 目的是让compiler支持变量和函数
* STL高级用法

### 七. Storage类
* Storage类用来存储一些变量和常量的值
* 我们发想SymbolTable只是Storage类中函数参数使用到, 而不是Storage类的成员变量, 所以两者间是依赖关系
* 如果类A负责类B的周期, 那么则是组合关系


### 九. bug分析解决
* 表达式是空的, 所以解析到的树为空
* 1+1=2 合法!
* 1 = 3
* 1+(1-4
* 1+(-)

==> 有了增加了status状态, 上面的问题基本就的到了解决

### 十. 让计算器支持函数计算
* 函数表FunctionTable里面保存的是 字符串 与 对应数学函数的关系, 实际上保存的是函数指针
* 函数认为是一元运算节点
* 不足之处: 内存控制, 异常处理


================================== 模板 ===============================
### 69. 
当需要编写一个函数, 支持传入不同的数据类型时:
* 宏替换: 1. 不做类型检查; 2. a++问题
* 重载: 1. 冗余, 一改全得改; 2. 不灵活, 支持类型受限

模板则结合了上面两者的优点. 模板是一种静态多态, 编译时完成函数模板程度实例化操作. 

(1) 注意点
模板在编译时, 其实是被编译了两次. 所以模板的声明和编译应该放在同一个文件中, 一般都统一放在头文件里面. 另外, 也可以用 `#include<xxx.cpp>` 

(2) 函数模板特化
特化会对指定的特定类型进行特殊对待, 用法就是声明时使用 `template<>` 即可

(3) 模板函数重载

(4) 非模板函数重载
如果使用了非模板函数, 则默认会去调用非模板函数, 要调用模板函数, 要使用显示自动推导.

(5) 显式指定类型的模板函数

### 71.md
#### 适配器
使用 "缺省模板参数" 类模板的扩展

#### 成员模板
不同类型的对象相互赋值等

#### typename
```
template <T>
class A {
    private:
        typename T::IntType *t_;   
};

class Type {
    public:
        typedef int IntType;
};
```
使用时:   
`A<Type> a; `

#### 模板与派生 -> 面向对象与泛型


### 72.md
#### 类模板单例模式
`typedef Singleton<SourceClass> SingleClass`
此行代码将普通类通过模板包装成为"单例模式类"

#### 线程安全的单例模式类
* 普通的锁
* double check lock
* linux 下使用 pthread_once()

#### 动态创建对象
--> 目的: 使用字符串动态创建对应的对象
用模板代替宏展开

####

