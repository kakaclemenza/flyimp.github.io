---
layout: post
title: go_in_action
category: coder
typora-root-url: ../../../..
---

### 一. 程序框架

代码实例: https://github.com/goinaction/code/tree/master/chapter2/sample

package: 

* 同一个目录下的所有.go文件不许声明同一个包名. 
* 一个包定义一组编译过的代码, 类似命名空间. 同一包下各文件定义相互可见
* `mian`包比较特殊, 当main包里同时有main()函数定义时, 编译程序会把这种包编译为二进制可执行文件, 二进制文件名会使用声明 main 包的代码所在的目录的目录名

导入包import:

* import导入标准库时, 只需给出包相对路径. 编译器查找包的时候, 会先到 GOROOT 中查找标准库的包, 再到 GOPATH 环境变量设置的位置去查找. 详细路径通过`go env`来查找
* import支持**远程导入**, 可以使用如`import github.com/spf13/viper`这种形式导入github上的包, 然后使用`go get`即可自动将该包下载到GOPATH目录下
* 如果需要导入多个包, 一般将多个包路径包装在一个导入块中, 格式如`import (...)`
* 导入的包同名的话, 可以使用**命名导入**的方式给导入包重命名, 如: `import stdfmt "fmt"`
* import导入第三方包时, 使用所在的路径名来导入, 导入后使用包名来引用其中定义
* `_`可以在导入路径前, 让 Go 语言只调用包中init()函数, 但是并不使用包里的标识符定义
* 对于可执行代码文件, 其init()函数会在main()函数前执行. 同一个包甚至同一个文件中, init()函数可以定义任意多个.

标识符与关键字: 

* 小写开头的标识符, 只在包内可见. 大写开头的才可以在包外被使用
* 关键字 defer 会安排随后的函数调用在函数返回时才执行. 调用后执行体就会入defer栈, 在函数退出/**意外崩溃**时依次出栈执行

变量:

* 所有变量的初始值为其零值. 所以, 像map类型的这种隐式指针类型, 必须使用make()来构造, 否则不能直接使用.
* 

函数: 

* 函数的定义如: `func 函数名(参数列表) 返回值 {...}`
* 函数可以返回多个值. 一般返回值中有一个err标明是否发生错误, 一般原则是如果发生错误, 永远不使用其他返回值
* go中所有变量都是以值的方式传递

方法:

* 

复杂的类型

* 数组: 数组是构造切片和映射的基石
* 切片和映射: go语言不直接使用数组, 而是使用切片来处理数据的集合. 切片和映射都可以自动增长, 切片是通过内置append()函数来实现自动增长的, 而映射本身就没有容量限制.
* 创建切片和映射有两种方式, 一直是使用make(), 另一种是使用字面量. 另外也可以创建nil切片和nil映射, 在没有赋值具体实体时, 不能对nil切片和nil映射做任何增删操作.
* 使用字面量方式创建切片时要注意, `[]`运算符里如果指定了值或`...`, 则创建的是数组, 只有当`[]`中为空时, 创建的才是切片.
* 映射map: 类型查找使用`the_map[key]`这种格式, 如果键存在, 则返回其值, 如果键不存在, 则返回零值. 另一种格式, 赋值给两个变量, 另一个变量是布尔形, 指定是否找到
* 切片, 函数以及包含切片的结构由于具有引用语义, 不能作为映射的键.
* 切片和映射的迭代都可以通过range. 迭代中range返回的是每个元素的副本, 赋值给同一个临时变量.
* **迭代中删除元素, 会如何?**

接口:

* interface{} 可与具体类型比较, 不会导致panic, 如:
  
  ```go
  var a interface{} = []int{1}
  fmt.Println(a == 1) //false
  ```

* interface{}与interface{}比较, 当且仅当两个都为dynamic type, 则会panic, 如:
  
  ```go
  var a interface{} = []int{1}
  var b interface{} = []int{2}
  fmt.Println(a == b) //panic: runtime error: comparing uncomparable type []int
  ```
  
  

反射reflect

* 

二. go并发

操作系统会在物理处理器上调度线程来运行, 而go语言的运行时会在逻辑处理器上调度
goroutine来运行, **每个逻辑处理器都分别绑定到单个操作系统线程**. 在go1.5版本之后, Go语言的运行时默认会为每个可用的物理处理器分配一个逻辑处理器

并发和并行的区别: 并行是让不同的代码片段同时在不同的物理处理器上执行. 并行的关键是同时做很多事情, 而并发是指同时管理很多事情, 这些事情可能只做了一半就被暂停去做别的事情了. 比如我电脑上的4核CPU, 他的并行是4, 并发则可能是40000

go自带了竞争状态检测工具, 见下节介绍.

解决竞争/同步问题, 可以使用:

* 原子函数
* lock锁
* 通道: 推荐使用

三    . go工具

go相关命令

* go vet: 检查常见错误
* go fmt: 自动格式化
* go doc: 查文档. 自己的注释要生成文档, 只需遵循注释紧跟在函数/包名之前即可.

go依赖管理: 前面说到`go get`可以自动获取远程导入的依赖包, 但是却无法确定获取的是哪个版本. go的依赖管理目前还是使用第三方工具, 解决特定版本依赖包导入的问题.

* godep: 兼容go工具链, 在依赖管理之后, 导入路径**需要重写**成工程内部依赖包的路径

* vendor属性: 本地创建个vendor目录, 依赖会先在vendor目录查找, 找不到再到GOPATH中找.

* gb工具链: 既不包装 Go 工具链, 也不使用 GOPATH, 是一个独立的工程构建工具. 在工程目录下, 开发人员代码在`src/`中, 第三方依赖代码在`vendor/src/`中, gb 工具首先会在$PROJECT/src/目录中查找代码, 如果找不到, 会在$PROJECT/vender/src/目录里查找. 这样不需要配合重写导入路径也可以完成整个构建过程, 同时可以把整个工程放到磁盘的任意位置. 编译使用:
  
  ```shell
  gb build all
  ```

* go1.13版本官方推出的`go modules`: **推荐**! 
  
  ```shell
  # 生成本地go.mod依赖描述文件
  go mod init
  ```

* 检测竞争状态: 首先在编译时加上竞争检测器标记, 然后运行编译好的程序, go就会提示有数据竞争的代码行
  
  ```shell
  # 用竞争检测器标志来编译程序
  go build -race
  
  # 运行程序
  ./example
  ```
