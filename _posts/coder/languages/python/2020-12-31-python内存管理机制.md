---
typora-root-url: ../../../../
---



# Python内存管理机制

## 什么是内存管理器（what）

Python作为一个高层次的结合了解释性、编译性、互动性和面向对象的脚本语言，与大多数编程语言不同，Python中的变量无需事先申明，变量无需指定类型，程序员无需关心内存管理，Python解释器给你自动回收。开发人员不用过多的关心内存管理机制，这一切全部由python内存管理器承担了复杂的内存管理工作。

内存不外乎创建和销毁两部分，本文将围绕python的内存池和垃圾回收两部分进行分析。

### Python内存池

#### 为什么要引入内存池（why）

当创建大量消耗小内存的对象时，频繁调用new/malloc会导致大量的内存碎片，致使效率降低。内存池的作用就是预先在内存中申请一定数量的，大小相等的内存块留作备用，当有新的内存需求时，就先从内存池中分配内存给这个需求，不够之后再申请新的内存。这样做最显著的优势就是能够减少内存碎片，提升效率。

> python中的内存管理机制为Pymalloc

#### 内存池是如果工作的（how）

首先，我们看一张CPython(python解释器)的内存架构图：

![img](/img/coder/languages/python_mem1.png)

- python的对象管理主要位于Level+1~Level+3层
- Level+3层：对于python内置的对象（比如int,dict等）都有独立的私有内存池，对象之间的内存池不共享，即int释放的内存，不会被分配给float使用
- Level+2层：当申请的内存大小小于256KB时，内存分配主要由 Python 对象分配器（Python’s object allocator）实施
- Level+1层：当申请的内存大小大于256KB时，由Python原生的内存分配器进行分配，本质上是调用C标准库中的malloc/realloc等函数

> 关于释放内存方面，当一个对象的引用计数变为0时，Python就会调用它的析构函数。调用析构函数并不意味着最终一定会调用free来释放内存空间，如果真是这样的话，那频繁地申请、释放内存空间会使Python的执行效率大打折扣。因此在析构时也采用了内存池机制，从内存池申请到的内存会被归还到内存池中，以避免频繁地申请和释放动作。

### 垃圾回收机制

Python的垃圾回收机制采用引用计数机制为主，标记-清除和分代回收机制为辅的策略。其中，标记-清除机制用来解决计数引用带来的循环引用而无法释放内存的问题，分代回收机制是为提升垃圾回收的效率。

#### 引用计数

Python通过引用计数来保存内存中的变量追踪，即记录该对象被其他使用的对象引用的次数。

Python中有个内部跟踪变量叫做引用计数器，每个变量有多少个引用，简称引用计数。当某个对象的引用计数为0时，就列入了垃圾回收队列。

```
>>> a=[1,2]
>>> import sys
>>> sys.getrefcount(a)  ## 获取对象a的引用次数
2
>>> b=a
>>> sys.getrefcount(a)
3
>>> del b  ## 删除b的引用
>>> sys.getrefcount(a)
2
>>> c=list()
>>> c.append(a) ## 加入到容器中
>>> sys.getrefcount(a)
3
>>> del c  ## 删除容器，引用-1
>>> sys.getrefcount(a)
2
>>> b=a
>>> sys.getrefcount(a)
3
>>> a=[3,4]  ## 重新赋值
>>> sys.getrefcount(a)
2
复制代码
```

> **注意：当把a作为参数传递给getrefcount时，会产生一个临时的引用，因此得出来的结果比真实情况+1**

- 引用计数增加的情况：

1. 一个对象被分配给一个新的名字（例如：a=[1,2]）
2. 将其放入一个容器中（如列表、元组或字典）（例如：c.append(a)）

- 引用计数减少的情况：

1. 使用del语句对对象别名显式的销毁(例如：del b)
2. 对象所在的容器被销毁或从容器中删除对象（例如：del c ）
3. 引用超出作用域或被重新赋值（例如：a=[3,4]）

> 引用计数能够解决大多数垃圾回收的问题，但是遇到两个对象相互引用的情况，del语句可以减少引用次数，但是引用计数不会归0，对象也就不会被销毁，从而造成了内存泄漏问题。**针对该情况，Python引入了标记-清除机制**。

#### 标记-清除

标记-清除用来解决引用计数机制产生的循环引用，进而导致内存泄漏的问题 。 循环引用只有在容器对象才会产生，比如字典，元组，列表等。

“标记-清除”并不改动真实的引用计数，而是将集合中对象的引用计数复制一份副本. 顾名思义，该机制在进行垃圾回收时分成了两步，分别是：

- 标记阶段，遍历所有的对象，如果是可达的（reachable），也就是还有对象引用它，那么就标记该对象为可达
- 清除阶段，再次遍历对象，如果发现某个对象没有标记为可达（即为Unreachable），则就将其回收

```
>>> a=[1,2]
>>> b=[3,4]
>>> sys.getrefcount(a)
2
>>> sys.getrefcount(b)
2
>>> a.append(b)
>>> sys.getrefcount(b)
3
>>> b.append(a)
>>> sys.getrefcount(a)
3
>>> del a
>>> del b
复制代码
```

- a引用b,b引用a,此时两个对象各自被引用了2次（去除getrefcout()的临时引用）

![img](/img/coder/languages/python_mem2.png)

- 执行del之后，对象a,b的引用次数都-1，此时各自的引用计数器都为1，陷入循环引用

![img](/img/coder/languages/python_mem3.png)

- 标记：找到其中的一端a,因为它有一个对b的引用，则将b的引用计数-1

![img](/img/coder/languages/python_mem4.png)

- 标记：再沿着引用到b,b有一个a的引用,将a的引用计数-1，此时对象a和b的引用次数全部为0，被标记为不可达（Unreachable）

![img](/img/coder/languages/python_mem5.png)

- 清除: 被标记为不可达的对象就是真正需要被释放的对象

> 上面描述的垃圾回收的阶段，会暂停整个应用程序，等待标记清除结束后才会恢复应用程序的运行。**为了减少应用程序暂停的时间，Python 通过“分代回收”(Generational Collection)以空间换时间的方法提高垃圾回收效率。**

#### 分代回收

> 分代回收是基于这样的一个统计事实，对于程序，存在一定比例的内存块的生存周期比较短；而剩下的内存块，生存周期会比较长，甚至会从程序开始一直持续到程序结束。生存期较短对象的比例通常在 80%～90%之间。 因此，简单地认为：对象存在时间越长，越可能不是垃圾，应该越少去收集。这样在执行标记-清除算法时可以有效减小遍历的对象数，从而提高垃圾回收的速度，**是一种以空间换时间的方法策略**。

Python将所有的对象分为年轻代（第0代）、中年代（第1代）、老年代（第2代）三代。所有的新建对象默认是 第0代对象。当在第0代的gc扫描中存活下来的对象将被移至第1代，在第1代的gc扫描中存活下来的对象将被移至第2代。

> gc扫描次数（第0代>第1代>第2代）

当某一代中被分配的对象与被释放的对象之差达到某一阈值时，就会触发当前一代的gc扫描。当某一代被扫描时，比它年轻的一代也会被扫描，因此，第2代的gc扫描发生时，第0，1代的gc扫描也会发生，即为全代扫描。

```
>>> import gc 
>>> gc.get_threshold() ## 分代回收机制的参数阈值设置
(700, 10, 10)
复制代码
```

- 700=新分配的对象数量-释放的对象数量，第0代gc扫描被触发
- 第一个10：第0代gc扫描发生10次，则第1代的gc扫描被触发
- 第二个10：第1代的gc扫描发生10次，则第2代的gc扫描被触发

### 思考

#### 在标记-清除中，如果对象c也引用a,执行del操作后，会发生什么？

#### 对象a,b,c的引用关系如下图所示：

```
>>> a=[1,2]
>>> b=[3,4]
>>> c=a
>>> a.append(b)
>>> b.append(a)
复制代码
```

![img](/img/coder/languages/python_mem6.png)

- ref_count表示引用计数
- 对象a,b,c全部为reachable

#### 执行del之后，引用关系如下图所示：

```
>>> del a
>>> del b
复制代码
```

![img](/img/coder/languages/python_mem7.png)

- a,b,c的ref_count减1

#### 执行gc扫描

- 标记: a引用b,将b的ref_count减1到0，b引用a,将a的ref_count减1到1，将b放在unreachable下

![img](/img/coder/languages/python_mem8.png)

- 再循环:因为a是可达的，所以会递归地将从a节点出发可以达到的所有节点标记为reachable下，即为：

![img](/img/coder/languages/python_mem9.png)

- 清除:unreachable下没有可清除的对象，因此a,b,c对象不会被清除

### 总结

总体而言，python通过内存池来减少内存碎片化，提高执行效率。主要通过引用计数来完成垃圾回收，通过标记-清除解决容器对象循环引用造成的问题，通过分代回收提高垃圾回收的效率。



### 案例

1. python+cpp底层的实现, 在使用tcmalloc库之后, 会出现内存约占越多不释放的现象. 原因是tcmalloc内部需要手动调用清理函数, 才会释放小对象缓存.
