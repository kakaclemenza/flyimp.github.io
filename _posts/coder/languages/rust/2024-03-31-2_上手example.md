---
layout: post
title: 2_上手example
category: coder
typora-root-url: ../../../..
---

## 目标

快速掌握rust语言语法，总结一些要点和坑点。参考资料：

* 【参考】[rust圣经](https://course.rs/)：用于对语法做权威解释。
* 【动手】[rust by example](https://rustwiki.org/zh-CN/rust-by-example)：通过代码例子，快速掌握相关语法。
* 【参考】[Rusty Book(锈书)](https://rusty.course.rs/)：提供rust项目级参考和库用法示例。

主要方法是基于《rust by example》上每个知识点的示例，来快速掌握rust语言。

## 知识点大纲

1. Hello World
    1.1. 注释
    1.2. 格式化输出
    1.2.1. 调试（debug）=> `{:?}`，所有类型都可推导Debug特征，进行打印。
    1.2.2. 显示（display） => `{}`，标准库类型有实现，其他类型需要自行实现特征。
    1.2.3. 测试实例：List => 配合`?`，对列表中没有实现Display特征的元素，返回错误。
    1.2.4. 格式化 => 区分`{}`和`{:?}`、对齐、保留小数点。。。

2. 原生类型
    2.1. 字面量和运算符 => `let s ="hello"`，`s` 是**字符串字面量**，类型为 `&str` ！
    2.2. 元组
    2.3. 数组和切片 => ♥ 

3. 自定义类型
    3.1. 结构体 => 经典C风格结构体、元组结构体（事实上就是具名元组）、单元结构体（不带字段，在泛型中很有用）
    3.2. 枚举 => 枚举使用`enum`声明，引用枚举中元素使用`::`，枚举中的元素可以携带某个类型的值。
    3.2.1. 使用 use => 提供类似引用模块中的元素一样，方便应用枚举中的元素。
    3.2.2. C 风格用法
    3.2.3. 测试实例：链表 => `enum` 的一个常见用法就是创建链表
    3.3. 常量

4. 变量绑定 => ♥♥♥ 

  ```shell
  * Rust 中每一个值都被一个变量所拥有，该变量被称为值的所有者
  * 一个值同时只能被一个变量所拥有，或者说一个值只能拥有一个所有者。（赋值操作，注意判断所有权，区分"自动拷贝"、"所有权转移"）
  * 当所有者(变量)离开作用域范围时，这个值将被"丢弃(drop)"
  ```

  4.1. 可变变量 => `mut`关键字。
  4.2. 作用域和遮蔽
  4.3. 变量先声明
  4.4. 冻结 => `let x = x`，实际就是将x在作用域内重新绑定为不可变。

5. 类型系统
    5.1. 类型转换 => `as`关键字，只能显式声明转换。
                               检查类型，可以使用：

                               ```rust
    fn print_type_of<T>(_: &T) {
    	println!("{}", std::any::type_name::<T>())
    }
                               ```

  5.2. 字面量 => 实现字面量转型，直接在字面量后面添加类型后缀，如：`u8`等。
  5.3. 类型推断
  5.4. 别名 => `type NewType = i32;`，主要用途是避免写出冗长的模板化代码

6. 类型转换
    6.1. From 和 Into => 实现了`From`特征的类型，自动有了`Into`特征。
    6.2. TryFrom 和 TryInto
    6.3. ToString 和 FromStr => 标准库中大多数类型都实现了`FromStr`特征，使用对应`parse()`或`parse::<T>()`函数即可

7. 表达式 => 和语句做区分；代码块也是表达式。

8. 流程控制
    8.1. if/else => 判断条件表达式不用括号包裹；if-else条件选择是一个表达式，所有分支返回类型要相同。
    8.2. loop 循环 => 有个用途是尝试一个操作直到成功为止。
    8.2.1. 嵌套循环和标签 => `break/continue + 标签`来实现跳出外层循环。
    8.2.2. 从 loop 循环返回 => `break+表达式`来返回结果。
    8.3. while 循环
    8.4. for 循环和区间 => `for in` 结构可以遍历一个 `Iterator`（迭代器）。使用`a..b`或`a..=b`区间标记来创建迭代器，或对集合应用into_iter()、iter()、mut_iter()函数，来转化为迭代器，注意match的不同。
    8.5. match 匹配 => ♥ 分支所有可能的值都要被覆盖，或使用`_`代表其他所有值！ 
    8.5.1. 解构 => match匹配时，**也是通过赋值进行解构**，有多种方式对变量进行解构
      8.5.1.1. 元组 => `..` 可用来忽略元组的其余部分
      8.5.1.2. 枚举 => 需要 `#[allow(dead_code)]` 来消除警告，因为只使用了枚举类型的一种取值。
      8.5.1.3. 指针和引用 => ♥♥♥ 区分解构（destructure）和解引用（dereference）！

  ```shell
  区分所有权转移、引用、解构等概念：
  * 所有权转移：对于基本类型（栈上，大小固定），赋值操作通过"自动拷贝"方式完成；对于其他复杂类型（堆上），赋值使用"所有权转移"方式完成；
  * 引用：获取变量的引用，不改变其所有权，也叫"借用"。对变量使用`&val`获得它的"不可变引用"，使用`&mut`获得它的"可变引用"。（对应声明时使用：`ref`和`ref mut`）。注意：
  	（1）引用的作用域，在1.31之后变成最后一次使用的位置。
  	（2）在同一个引用作用域中，最多只能有一个"可变引用"！
  	（3）在同一个引用作用域中，"可变引用"与"不可变引用"不能同时存在！
  	（4）解引用：使用`*val`方式，来获得变量的值。
  	（5）自动引用和自动解引用："方法调用"、"println!宏"等"少数行为"能自动引用和自动解引用使得变量与类型匹配的能力。
  * 解构：用于match等场景，对匹配的变量值类型进行还原，如对于引用类型使用类似：`&val`；
  ```

  ​    8.5.1.4. 结构体 => `..` 也可用来忽略结构体某些部分
    8.5.2. 卫语句 => 匹配语句中可以后面添加 if 条件来进一步判断！
    8.5.3. 绑定 => 使用`n @ 1..=12 => xxx`的方式，来将匹配的变量绑定到名称。
  8.6. if let => 简化match只匹配一个值的场景，语法`if let expVal = val {}`，注意使用的是一个`=`，不需要实例具有可比性（实现 `PartialEq`）！
  8.7. while let => 

9. 函数 => 函数只能返回一个值，如果要返回多个值可以返回元组，如果没有显式返回则返回`()`
    9.1. 方法 => 放到`impl Struct类型 {}`中定义的是方法，分为静态方法（通过`类型名::方法()`调用）和实例方法（通过`实例.方法()`调用）。
    9.2. 闭包 => `|val| val + x`
      9.2.1. 捕获 => 闭包捕获的外部变量，会自动按可用性匹配：可变引用 < 不可变引用 < 值传递（复制或移动）。
      9.2.2. 作为输入参数 => 当使用闭包作为函数参数时，需要使用trait特性来指出闭包的完整类型，并且闭包参数是**泛型**。使用trait特性包括三种：
    
    ```shell
    Fn：表示捕获方式为通过引用（&T）的闭包
    FnMut：表示捕获方式为通过可变引用（&mut T）的闭包
    FnOnce：表示捕获方式为通过值（T）的闭包
    ```
  
    9.2.3. 类型匿名
    9.2.4. 输入函数 => 如果你声明一个接受闭包作为参数的函数，那么任何满足该闭包的 trait 约束的函数都可以作为其参数。
      9.2.5. 作为输出参数 => 闭包也可以作为输出参数，但是要满足：1、类似`fn xxx() -> impl Fn()`，用三种trait特性表明闭包类型；2、闭包要用`move`表明为值传递。 
      9.2.6. std 中的例子 => Iterator::any、Iterator::find
    9.3. 高阶函数 => 接收一个或多个函数作为输入，输出一个包含更有用的函数的类型，实现函数式编程（链式调用）。
    9.4. 发散函数 => `fn xxx() -> ! {}`，使用`!`指示函数永不返回。
    
10. 模块 => `mod 模块名 {}`
     10.1. 可见性 => 同一层次模块内的字段相互可见，可见性只影响不同层次模块间字段访问，默认是私有可见性。
     10.2. 结构体的可见性 => 结构体内字段也默认是私有可见性，同一层次模块内可以访问，其他模块不能访问。
     10.3. use 声明 => `use` 声明可以将一个完整的路径绑定到一个新的名字，从而更容易访问
     10.4. super 和 self =>  `super` （父级）和 `self`（自身）指定相对模块路径。
     10.5. 文件分层 => 模块的路径也可以转为rust文件路径；注意`my.rs` 等同于 `my/mod.rs`！

11. crate
      11.1. 库
      11.2. 使用库

12. cargo
      12.1. 依赖 => 可以从`creates.io`、github网址、本地路径等获取依赖。
      12.2. 约定规范
      12.3. 测试
      12.4. 构建脚本 => 在crate编译前，进行先决条件的编译。

13. 属性 => `#[item_attribute]`用于模块或项；`#![crate_attribute]`用于整个crate。
      13.1. 死代码 dead_code => `#[allow(dead_code)]` 属性可以禁用 `dead_code`告警。
      13.2. crate => 在使用 cargo 时， `crate_type` 和 `crate_name` 属性没有作用！
      13.3. cfg => 实现**条件编译**，在属性位置中使用 `#[cfg(...)]`，在布尔表达式中使用 `cfg!(...)`。
        13.3.1. 自定义条件 

14. 泛型 => ♥♥♥ 类型参数：把 类型 当作参数。泛型的类型参数是使用尖括号和[大驼峰命名](https://en.wikipedia.org/wiki/CamelCase)的名称， 如`T`。
      14.1. 函数 => 
      14.2. 实现 => `impl <T> GenVal<T> { xxx }`
      14.3. trait => trait也可以是泛型。`impl <T, U> Print<T> for U { xxx }`，对调用者类型`U`实现trait泛型`Print<T>`的特征！
      14.4. 约束 => 多数情况下，使用泛型类型会使用trait特征进行约束，语法如`<T: Debug>`，对于泛型类型T使用`Debug`特征进行约束。约束后的T可以通过`{:?}`来打印。
        14.4.1. 测试实例：空约束 
      14.5. 多重约束 => 对于某个类型参数如果有多重约束，可以用 `+` 连接
      14.6. where 子句
      14.7. newtype 惯用法
      14.8. 关联项
      14.8.1. 存在问题
      14.8.2. 关联类型
      14.9. 虚类型参数
      14.9.1. 测试实例：单位检查

15. 作用域规则
      15.1. RAII => Rust 强制实行 [RAII](https://en.wikipedia.org/wiki/Resource_Acquisition_Is_Initialization)，所以任何对象在离开作用域时，它的析构函数（destructor）就被调用，然后它占有的资源就被释放。析构函数概念是通过 [`Drop`](https://rustwiki.org/zh-CN/std/ops/trait.Drop.html) trait 提供的。
      15.2. 所有权和移动 => 结构体中字段可以被部分移动！
      15.3. 借用 => `ref` 可用于对结构体/元组的字段进行借用。
      15.4. 生命周期
        15.4.1. 显式标注
        15.4.2. 函数
        15.4.3. 方法
        15.4.4. 结构体
        15.4.5. trait
        15.4.6. 约束
        15.4.7. 强制转换
        15.4.8. static
        15.4.9. 省略
    
16. 特质 trait
      16.1. 派生
      16.2. 使用 dyn 返回 trait
      16.3. 运算符重载
      16.4. Drop
      16.5. Iterator
      16.6. impl Trait
      16.7. Clone
      16.8. 父 trait
      16.9. 消除重叠 trait

17. 使用 macro_rules! 来创建宏
      17.1. 语法
      17.1.1. 指示符
      17.1.2. 重载
      17.1.3. 重复
      17.2. DRY (不写重复代码)
      17.3. DSL (领域专用语言)
      17.4. 可变参数接口

18. 错误处理
      18.1. panic
      18.2. Option 和 unwrap
        18.2.1. 使用 ? 解开 Option => 使用 ? 解开 Option，若 x 是 Some ，对x?表达式求值将返回底层值，否则无论函数是否正在执行**都将终止且返回 None**。
        18.2.2. 组合算子：map
        18.2.3. 组合算子：and_then
      18.3. 结果 Result
        18.3.1. Result 的 map
        18.3.2. 给 Result 取别名
        18.3.3. 提前返回
        18.3.4. 引入 ?
      18.4. 处理多种错误类型
      18.4.1. 从 Option 中取出 Result
      18.4.2. 定义一种错误类型
      18.4.3. 把错误 “装箱”
      18.4.4. ? 的其他用法
      18.4.5. 包裹错误
      18.5. 遍历 Result

19. 标准库类型
      19.1. 箱子、栈和堆
      19.2. 动态数组 vector
      19.3. 字符串 String
      19.4. 选项 Option
      19.5. 结果 Result
      19.5.1. ? 用法
      19.6. panic!
      19.7. 散列表 HashMap
      19.7.1. 更改或自定义关键字类型
      19.7.2. 散列集 HashSet
      19.8. 引用计数 Rc
      19.9. 共享引用计数 Arc

20. 标准库更多介绍
      20.1. 线程
      20.1.1. 测试实例：map-reduce
      20.2. 通道
      20.3. 路径
      20.4. 文件输入输出（I/O）
      20.4.1. 打开文件 open
      20.4.2. 创建文件 create
      20.4.3. 读取行 read lines
      20.5. 子进程
      20.5.1. 管道
      20.5.2. 等待
      20.6. 文件系统操作
      20.7. 程序参数
      20.7.1. 参数解析
      20.8. 外部语言函数接口

21. 测试
      21.1. 单元测试
      21.2. 文档测试
      21.3. 集成测试
      21.4. 开发依赖

22. 不安全操作

23. 兼容性
      23.1. 原始标志符