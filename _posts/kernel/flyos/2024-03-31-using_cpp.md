---
layout: post
title: using_cpp
category: kernel
typora-root-url: ../../..
---

### 这里总结使用CPP中要注意的地方  
> 标注格式为:
> * (版本号) 重要内容   
> 详细说明


* 提交 dbefe3c 中, Makefile 中的 -O2 必须改成 -O1 编译, 否则优化过度会导致 wipeout() 清屏异常.

* 使用 std::array 替代 C数组 的优势:  
  std::array 相对于 std::vector 而言，提供了静态数组，编译时确定大小、更轻量、更效率，当然也比 std::vector 有更多局限性。但是相对于 C array 而言，又更加安全，更加方便，提供了 STL 的各种迭代器、算法、操作方法等，用起来有现代语言的快感。差不多就是 vector 和 C array 的中和版本。   
  有size()，有iterator，可以用begin()/end()和algorithm谈笑风生。比C array不知道高到哪里去了。

* (83f6ffa)通过在开头制定行列位置, 修复清屏不完全的bug

* __attribute__ 编译器优化相关
  __attribute__ ((packed)) 的作用就是告诉编译器取消结构在编译过程中的优化对齐,按照实际占用字节数进行对齐   
  __attribute__((noreturn))就是告诉编译器这个函数不会返回给调用者，以便编译器在优化时去掉不必要的函数返回代码。

* 关于中断的复习:
  IRQ 中断请求   
  ISR 中断服务程序   
  更具体的解释(来自百度百科):   
  一个外部中断请求信号通过中断请求线IRQ，传输到IMR（中断屏蔽寄存器），IMR根据所设定的中断屏蔽字（OCW1），决定是将其丢弃还是接受。如果可以接受，则8259A将IRR（中断请求暂存寄存器）中代表此IRQ的位置位，以表示此IRQ有中断请求信号，并同时向CPU的INTR（中断请求）管脚发送一个信号。但CPU这时可能正在执行一条指令，因此CPU不会立即响应。而当这CPU正忙着执行某条指令时，还有可能有其余的IRQ线送来中断请求，这些请求都会接受IMR的挑选。如果没有被屏蔽，那么这些请求也会被放到IRR中，也即IRR中代表它们的IRQ的相应位会被置1。   
  当CPU执行完一条指令时后，会检查一下INTR管脚是否有信号。如果发现有信号，就会转到中断服务，此时，CPU会立即向8259A芯片的INTA（中断应答）管脚发送一个信号。当芯片收到此信号后，判优部件开始工作，它在IRR中，挑选优先级最高的中断，将中断请求送到ISR（中断服务寄存器），也即将ISR中代表此IRQ的位置一，并将IRR中相应位置零，表明此中断正在接受CPU的处理。同时，将它的编号写入中断向量寄存器IVR的低三位（IVR正是由ICW2所指定的，不知你是否还记得ICW2的最低三位在指定时都是0，而在这里，它们被利用了！）这时，CPU还会送来第二个INTA信号，当收到此信号后，芯片将IVR中的内容，也就是此中断的中断号送上通向CPU的数据线。   


* enum class
更安全的 enum 用法, C++11标准, 让enum的声明值处于作用域之中, 以后对值的引用也要指定枚举体作用域.
