---
layout: post
title: 网络子系统相关问题
category: kernel
typora-root-url: ../../..
---

带着解决问题的学习和研究, 往往是更有效率的, 并且也会印象深刻. 尤其是对于像内核子系统这样庞大的系统. 以下总结工作学习中遇到的问题和它对应的网络子系统原理, 以及如何基于原理解决相应的问题.



### tcpdump抓到tcp大于MSS的数据包

#### Nagle算法相关

一开始怀疑是因为开启了nagle算法导致的粘包问题. nagle算法是用于对缓冲区内的一定数量的消息进行自动连接。该处理过程(称为Nagling)，通过减少必须发送的封包的数量，提高了网络应用程序系统的效率。

**1.** **Nagle算法的规则**

（可参考tcp_output.c文件里tcp_nagle_check函数注释）：
1）如果包长度达到MSS(MSS是最大分段大小Maxitum Segment Size ，MTU是最大传输单元Maxitum Transmission Unit)，则允许发送；
2）如果该包含有FIN，则允许发送；
3）设置了TCP_NODELAY选项，则允许发送；
4）未设置TCP_CORK选项时，若所有发出去的包均被确认，或所有发出去的小数据包(包长度小于MSS)均被确认，则允许发送。
   对于规则4），就是说一个TCP连接上最多只能有一个未被确认的小数据包，在该分组的确认到达之前，不能发送其他的小数据包。如果某个小分组的确认被延迟了，那么后续小分组的发送就会相应的延迟。也就是说延迟确认影响的并不只是被延迟确认的那个数据包，而是后续所有的应答包。

**2.** **Nagle算法的门槛**

实际上Nagle算法并不是很复杂，他的主要职责是数据的累积，实际上有三个门槛：

1）缓冲区中的字节数达到了一定量；
2）等待了一定的时间（一般的Nagle算法都是等待200ms）；
3）紧急数据发送。

   这三个门槛的任何一个达到都必须发送数据了。一般情况下，如果数据流量很大，第二个条件是永远不会起作用的，但当发送小的数据包时，第二个门槛就发挥作用了，防止数据被无限的缓存在缓冲区不是好事情哦。

**3. TCP_CORK选项**

TCP_CORK选项与TCP_NODELAY一样，是控制Nagle化的。      

1）打开TCP_NODELAY选项，则意味着无论数据包是多么的小，都立即发送（不考虑拥塞窗口）。
2）如果将TCP连接比喻为一个管道，那TCP_CORK选项的作用就像一个塞子。            

   设置TCP_CORK选项，就是用塞子塞住管道，而取消TCP_CORK选项，就是将塞子拔掉. 当TCP_CORK选项被设置时，TCP链接不会发送任何的小包，即**只有当数据量达到MSS时，才会被发送. 一般当数据传输完成时**，通常需要取消该选项，以防被塞住，这样才可以让不够MSS大小的包能及时发出去



#### TSO/LRO->GSO/GRO

从上面看出, nagle算法发送的缓冲区数据如果达到MSS是会被立即发送的, 不会产生大于MSS的tcp包. 而TCP_CORK则需要特殊编程, 一般不会这么做.

那是什么原因呢? 网上查到有说明本机开启TSO情况下, tcp分段会交给网卡处理, 所以tcpdump在链路层处理时抓到的包是还没有分段的, 因此会大于MSS. 

类比到代理上, 出现的原因可能也是网卡硬件支持了tcp包的分段和重组, 不过由于我的代理是netfilter在ip层对数据包头的修改操作, 不涉及传输层的具体协议, 不应该和TSO相关. 于是想到GSO/GRO.

TSO也叫LSO, 对应的是LRO, 仅针对TCP协议, **需要网卡硬件支持**; 而进一步的所有协议通用版就是GSO/GRO了. 另外(1)UFO(UDP fragmentation offload)由于没有存在的意义, 最新的内核已将其和GSO/GRO合并; (2)LRO原理上有漏洞, 最新网卡已不支持.

GSO/GRO不依赖硬件, 因为要尽可能晚的分段或者分片, 所以在发给网卡驱动时检查网卡是否支持TSO, 如果支持, 将大包直接传给网卡驱动. 如果不支持, 再做GSO, 即在发给网卡驱动的前一刻将大包分成多个小包

根据LinuxFoundation的文档，在MTU1500时，使用GSO可以使得网络吞吐量（throughput）提升17.5%。

所以抓到大包的原因如下:

```
游戏服-->代理网卡gro-->tcpdump入口包抓包点(__netif_receive_skb)
	-->ip层netfilter钩子-->...
-->tcpdump出口包抓包点(dev_queue_xmit_nit)-->代理网卡gso->客户端
```

可以通过ethtool设置关闭GSO/GRO, 可以验证抓到的包大小正常了:

```bash
# 关闭
ethtool -K eth0 gso off
ethtool -K eth0 gro off
# 检查网卡状态
ethtool -k eth0
```



ref:

TSO/LRO, GSO/GRO了解: https://zhuanlan.zhihu.com/p/44683790

GSO/GRO源码分析: https://blog.csdn.net/u011130578/article/details/44676125