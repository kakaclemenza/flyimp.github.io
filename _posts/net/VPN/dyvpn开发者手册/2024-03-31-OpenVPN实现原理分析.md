---
layout: post
title: OpenVPN实现原理分析
category: net
typora-root-url: ../../../..
---

### vpn入门了解

1. 当前业界软件加速器概述:
https://www.cnblogs.com/chengxuyuandashu/p/3801490.html

2. 最好的方式还是自己搭建下openvpn服务, 最麻烦的其实就是生成服务端客户端证书和密钥, 后面就是运行服务端参数指定服务端证书, 运行客户端参数指定客户端ovpn配置文件就行了:
https://qhh.me/2019/06/16/Cenos7-%E4%B8%8B%E6%90%AD%E5%BB%BA-OpenVPN-%E8%BF%87%E7%A8%8B%E8%AE%B0%E5%BD%95/

3. 更深入的讲原理的: (原始来自csdn dog250大牛, 不过被平台删了...)
https://juejin.im/post/5c11c4e2f265da61602ccb9d

4. 进一步认识对比: BadVPN
https://www.geek-share.com/detail/2703798916.html



### 定义及概念

VPN 虚拟专用网络. 它其实有两层含义:

* V: 虚拟的. 并不需要物理布线, 仅仅在逻辑上实现一个网络. 这依赖于网络分层模型, 理论上任何层次的数据都可以被承载在其它的任何层次或者它当前的层次上. 于是就出现了很多XX over YY的网络模型. ipsec隧道就是一个ip over ip的网络模型
* P: 私有的, 专用的. ipsec使用ah协议和esp协议实现了安全, 保证隧道的专用, 否则别人都可以进入你的虚拟网络了

然而IPSec的隧道模式实现的VPN有一个缺陷, 那就是很难穿越nat，因为nat要修改ip头，一旦ip头被修改了，那么最终的ah或者esp的认证加密的校验结果就会出错，因此就不能随意在nat的网络环境中使用IPSec实现的VPN，当然不涉及ip头认证的IPSec协议还是可以用的, 但IPsec属于协议栈, 不好方便进行太多的自定义.

更好的方式就是使用上层协议来承载下层的数据包, 上层实现会很灵活, 即ip over ssl

### 如何实现ip over ssl呢

要做的是两点:

* 第一: 数据必须按照协议栈的标准逐级封装和解封装，不能修改协议栈. 
* 第二: 就是数据到了最下面物理层的时候不能真的走掉，而是回到用户空间

一种方法是利用loopback网卡配合抓包实现, 但由于太过复杂且影响性能, 所以此法不通. (参见: https://blog.51cto.com/dog250/1271907)

于是乎虚拟网卡tun/tap设备就成了很好的选择. 以下总结ip over ssl使用tun/tap设备实现的流程图:



假定游戏服ip为121.201.64.81, 从本地OpenVPN对于路由表的修改, 如下规则的添加为关键所在

路由规则与配置:

* USER端: 
  * 121.201.64.81/32 via 10.0.0.2 dev tun0 : **这条将10.0.0.2作为访问121.201.64.81的网关!**
  * 10.0.0.2 dev tun0 proto kernel scope link src 10.0.0.1 : **这条确保了到达网关10.0.0.2的路由**
* ovpn服务器网关端: 
  * default via 6.7.8.9 dev eth0
  * 且SERVER端开启(1)开启ip_forward; (2)启用eth0上SNAT或MASQUERADE规则; 

```
                 PKG_IN: 10.0.0.1:56789+>121.201.64.81:8080
              PKG_OUTER: 4.5.6.7:1567+>6.7.8.9:443

   +-----+   +-----+                    +-----+           121.201.64.81/32
   |USER |   | ssl +-------+            | ssl +-------+       +--------+
   +--+--+   +--+--+       |            +--+--+       |       | SERVER |
      |         ^          |               ^          |       +---+----+
      |         |          |               |          |           ^
      |         |          |               |          |           |
      |         |          |               |          |           |
xmit()|         |          |               |          |       default route
      |         |          v               |          |       + IP_FORWORD
      |      +--+--+    +--+--+         +--+--+    +--v--+        |
      +----->+tun0 |    |eth0 +-------->+eth0 |    |tun0 +--------+
             +-----+    +-----+         +-----+    +-----+
          10.0.0.1/24   4.5.6.7/32    6.7.8.9/32  10.0.0.2/24

```

通过服务端tun0网卡和eth0网卡对udp+icmp**抓包测试**, 可以总结出数据包处理流程如下

发包方向流程: 

* USER端协议栈发送数据包给121.201.64.81, 本地路由判断数据包从tun0网卡发出, 源地址选择10.0.0.1
* 从tun0网卡发出数据包, 可在其字符驱动中读取出来. ovpn将数据包取出, 封装ssl协议包头, 发给6.7.8.9
* USER端路由判定发给6.7.8.9, 从eth0发出, 源地址为4.5.6.7
* 数据包到达ovpn服务器, eth0收包上送到ovpn服务端进程, ovpn服务端对ssl协议包做验证, 解包
* 解出的载荷ip包, 直接写入服务端tun0字符设备, 这样载荷ip包就直接通过tun0进入协议栈, 由协议栈重新路由并发送
* 服务端路由判定数据包通过ip_forward发送给121.201.64.81, 服务端作为网关处理, 生成ct记录链接转换规则.

回包方向的考虑: 

* 在网关6.7.8.9上由于ct记录会像下面这样

  ```
  (ORIGIN, 10.0.0.1:56789, 121.201.64.81:8080)
  (REPLY, 121.201.64.81:8080, 6.7.8.9:38371)
  ```

* 于是在网关上, 回包会按ct修改为"121.201.64.81:8080->10.0.0.1:56789", 按路由, 回包会从网关上的tun0网卡发出(图中没有画出, 这里它的ip是10.0.0.2). 由于其上的OpenVPN进程监听tun0网卡, 所以发出的数据包被OpenVPN通过字符设备读取, 又经过ssl加密封装, 发给OpenVPN服务器中管理的10.0.0.1对应的USER: 4.5.6.7:1567.

* USER收到ssl封装的包, 解封后发现10.0.0.1是自己, 于是上交给应用进程.







### 附录: dog250博文搜索方式

读大神的博文通常能加快对于某事物的学习速度(注意甄别真假大神, 大多博文是人云亦云, 说的其实都是有误的). 但是大神的博文永远无法保证一直存在, 法律, 平台和个人等因素完全可以导致一系列博文从网上消失. 目前dog250关于VPN的博文已经在csdn上消失, 51cto上则还有保留, 搜索方式:

目录: https://blog.51cto.com/dog250/1270907

从目录中找到复制对应的标题, 然后到51cto搜索该标题, 定位到dog250作者的文章即可.

对于部分博文缺失图片, 首先关掉ADBlock刷新看看, 否则拷贝标题到百度找其他博主复制过去的文章.



### 问题: windows如何支持GRE tunnel, 实现简单的overlay

Windows doesn't support GRE. You can  use IPsec, or PPTP/L2TP. GRE & IP-in-IP can be used on **Microsoft Windows** via a client developed for X4B customers

https://www.x4b.net/kb/WindowsIPIPTunnel



gre over ipsec和ipsec over gre两种方式的目标, 都是为了实现对于不安全的gre隧道的加密. 选择ipsec over gre方式会更好些, 因为数据先经过ipsec加密, 再在gre隧道上传输, 这样数据包不会受限于ipsec加密导致NAT无法穿越的问题(在不支持NAT-T的路由器上也能正常传输). 

调研了多种VPN实现方式, 其中OpenVPN会因为其实现问题(用户态导致并发上限, 以及本身的单线程模型)导致单台节点服承载能力十分有限, 默认已经被我排除了. 另外两种是基于gre的PPTP和基于IPsec的L2TP, 这两种VPN的服务器承载能力还需进一步调查. 另外技术实现的难点在客户端上, windows上目前没有找到很好的方法自定义隧道实现overlay网络, 需要继续寻找答案, 比如基于OpenVPN客户端修改实现用户态的gre隧道等等.



### 实现替换xxmygw现有代理方式的可行方案

* 最终目标是实现客户端到代理点的p2p tunnel
* 代理点使用gre/ipip, 修改内核模块, 使得(1)可直接接收gre包, 不必使用ip命令配置. (2)集中在单一虚拟网卡可以接收多客户端数据包.
* 客户端使用tun设备+用户态程序封装数据包进gre/ipip协议.
* gre隧道穿越NAT的可行性分析(由于ipsec over gre方式可行, gre理论上是可以自由穿越NAT的)
* 代理点上配置iptables FORWARD规则允许授权ip进行转发.