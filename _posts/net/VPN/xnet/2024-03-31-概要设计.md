---
typora-root-url: ../../../../
---



### 一. 总述

枪火网络统计: 

1. 总体掉线率较高
2. 总体延迟较高
3. 最大延迟超过400ms占比超过一半
4. 非同运营商互联网络质量明显不如同运营商

需求: 在玩家间联机游戏的场景中, 网络传输质量没有好的控制方式, 进而影响游戏质量. 我们迫切需要一套定制化的高速网络通道, 来支撑玩家间联机需求

目标: 我们的目标, 是提供一个端到端完全可控的网络, 该网络能为接入的终端提供高效稳定安全的网络传输通道.

我们设计的网络系统, 暂定称为**vnet**, 即虚拟网络的意思. 



### 二. 总体设计

vnet主要有以下成员组成:

1. sdk: 接入vnet网路的sdk
2. AS: 用于获取最优AP接入点及其他信息
3. AP: 网络接入点
4. CC: sdn网络控制器

网络拓补如下:

![](/img/net/xnet/xnet_struct.png)



### 三. 外部接口

1. int errcode = InitNet(char *params): 初始化网络环境, 接入vnet网络
   * 初始化环境, 包括日志路径等
   * 向AS服请求最优接入点; 
   * 通过私有协议连接最优接入点
2. uint32_t[] netidLst = GetNetid(char *uuid): 
   * 客户端通过uuid获取到netid. 这个逻辑从InitNet()中独立出来, 是为了方便客户端要同时发数据给多个游戏服的场景.
   * 返回值是netid列表: 在服务端同时连了多个AP时, 会返回多个netid, 客户端可以在某个失败时立即向另一个netid发数据
3. int sentBytes = SendPkt(char *pkt, int netid): 发送数据包
4. int recvBytes = RecvPkt(char *pkt, int *netid): 接收数据包
5. void FiniNet(): 终止接入vnet网络



### 四. 模块设计

#### (1) AS

直接复用现有xxxvpn的AS接入服即可,  但由于要考虑客户端连接服务端需求, 接口功能有所变动, 如下:

* /accel: 
  * 选服策略按照"同运营商最近"下发至少三个不同机房节点
  * 如过作为客户端, 需要查找uuid对应的netid, 并返回给客户端
* /delay:
  * 收集测速结果
* /feedback: 
  * 收集接入结果
  * 如果作为服务端, 要绑定uuid->netid的对应关系, 以便客户端请求接入.

可能新增接口:

* /get_netid:
  * 请求uuid对应的netid整形列表

#### (2) CC

sdn的控制器负责管理sdn网络, 目前xxmysdn控制器就已经实现了必要的功能了, 直接复用即可. 其功能模块如下:

* monitor: 负责实时采集sdn网络各节点信息
* ruler: 负责从monitor获取sdn网络信息, 计算出最优流表; 必要时更新到sdn网络各节点.

#### (3) sdk与AP

sdk是本次设计的**开发重点**. sdk分为客户端sdk和服务端sdk; 客户端sdk由接入业务app调用, 主要完成网络接入, 数据收发功能; 服务端sdk由AP进行调用, 主要完成数据转发功能.

**设计要点**:

1. 客户端sdk->服务端sdk和服务端sdk->服务端sdk所采用的协议需要是一致的可靠传输协议, 以实现转发时只需判断包头, 无需修改包体
2. 数据包组包和解包逻辑都在客户端sdk完成. 组包主要是按协议构造vnet包头, 并填入用户数据作为包体

**交互流程**:

1. AP启服, 从etcd获取到绑定的AP_id, 及其他节点的AP_id信息, 传给服务端sdk
2. 服务端sdk根据绑定的AP_id: (1)构造出自己的网络ip, (2)运行并初始化本地ovs, (3)监听统一转发端口, (4)使用其他节点的AP_id信息连接其他AP
3. 用户调用InitNet(), 获得AP后, 客户端sdk连接服务端sdk: (1)发送PROTO_CTRL+OP_REQUEST协议; (2)服务端sdk验证token信息无误, 生成客户端sdk_id, 并记录sdk_id对应的conn连接信息; (3)将自己的AP_id与sdk_id组合生成netid, 通过PROTO_CTRL+OP_RESPONSE协议回复给客户端sdk. (4)接入成功后, 客户端sdk在内部保存自己的源netid
4. 客户端sdk若连不上, 要重试3次(参考xxxvpn). 
5. 客户端sdk连上服务端sdk后, 两端各自开启心跳探测goroutine(参考xxxvpn), 客户端还要开启echo测试goroutine
6. 用户调用SendPkt, 客户端sdk获得数据data, 目标netid, 加上内部保存的源netid, 就能使用PROTO_DATA+OP_NORMAL构造vnet数据包, 并通过客户端sdk和服务端sdk的连接发送出去.
7. AP收到这个vnet数据包, 读取vnet头部目标netid, 如果AP_id字段与自己的AP_id相同, 则通过sdk_id字段查到conn连接信息, 通过此连接信息将vnet数据包发出
8. 如果AP_id字段与自己的AP_id不同, 则通过AP_id字段查到对应的AP的连接信息, 通过此连接信息将vnet数据包发出
9. 用户调用RecvPkt()阻塞接收数据包. 数据包到来时, 客户端sdk拆除vnet包头, 确认目标netid是否与自己保存的netid相等, 相等将源netid, 数据data赋值给返回参数, 并返回接收到的数据长度. **不相等则数据包直接丢弃**

交互流程示例图:

![](/img/net/xnet/xnet_transfer_pkt.png)

### 五. 协议结构

预期采用kcp协议来实现可靠传输, 现在是采用kcp头包裹vnet头方式, 但更好的设计或许是vnet头包裹kcp头的方式, 这点需要深入kcp实现原理看看能否做到.

| 协议层     | 长度/Byte                                        |
| ---------- | ------------------------------------------------ |
| ip         | 20                                               |
| udp        | 8                                                |
| kcp        | 24                                               |
| vnet       | 11 [协议类型(1B) + 源netid (4B) + 目标netid(4B)] |
| 数据体data | 0~1400 (最大1437B)                               |

**协议类型**: 直接复用xxxvpn的协议中的code字段类型划分方法. 常量定义可能会稍微调整

**netid说明**: 一个netid就是sdk在这个网络中的地址标识, 类似ip地址的存在. netid(5B) = AP_id(2B) + sdk_id(3B); AP_id就是AP的编号, sdk_id就是接入到某个AP时该AP对这个sdk的编号. AP节点最多能65536个, 每个AP最多接入16777216个sdk客户端; 这是目前的规模, 后续可以按需调整.

**长数据包分段问题**: 设置kcp最大接收 1400B 数据, 分段和重组理论上应该由kcp处理, 需要进一步探究讨论.



### 六. 容灾设计

1. AS服一次下发多个不同机房的最优节点, InitNet()时会同时发起接入请求, 找最快返回的一个接入使用.

2. 如果接入节点故障, sdk会在心跳超时, 若是客户端故障, 则可以快速通过接入点接入, 如果服务端故障, 则自动终止连接, 重走接入流程. =>如果是服务器接入节点故障了怎么办, 客户端怎么再通过id索引到服务器??

   法一: 每次接入网络时, 都会从AS服获得uuid; 当不知道uuid对应的接入点时, 接入点会广播到其他接入点查找uuid. 这样不论是业务服务端还是客户端, 断连后绑定到相同的uuid, 就可从其他接入点重新接收包. **缺点**: 这样的话接入点压力会很大

   法二: 每次接入网络时, 都会从AS服获得uuid; 断线后, **作为服务器的节点可以向接入服重新协商uuid对应的netid**, 这样其他作为客户端的节点尝试重连时就能连上. 这样就需要设计uuid与netid的对应关系. **缺点:** 这决定了网络故障时, 最终要重走接入流程来获得新的uuid->netid映射关系

3. 如果中间部分路由节点故障, 则sdn网络会自动选择最优的通路

4. 某些流量集中的机房, 需要按需另外设计多个接入点, 让服务端使用sdk时能同时接入多个点, 这点有待进一步讨论.

5. 业务服务端与AP是长连接, 如果AP需要更新, 在go语言无法热更时怎么办? 必须要断开连接吗? 调研了下go确实没有很好的热更方案, 只能从以下方向入手:

   * 方向一: 再看看通过动态库加载的方式是否可行(网上一堆诟病)
   * 方向二: 让服务端sdk+AP的功能尽量简单且固定(和做一个底层引擎一样), 这样可以保证服务端sdk+AP无需更新
   
6. sdk访问接入点, 最好是用httpDNS服务



### 七. 监控设计

1. InitNet后会立即向AS服反馈接入网络成功与否
2. InitNet成功后, 会自动发起对接入点的持续测速. 
3. 可以通过内部可靠传输协议统计实际使用网络过程中的丢包率
4. AP接入点可以在接入注册netid, 断开或心跳超时释放netid这两个时间点写日志来定位客户端



### 八. 安全设计

#### AS服

请求验证: AS服设计采用md5动态计算token来验证客户端合法性

#### AP接入点

1. 接入验证: AP接入需要使用AS服下发的AP_token做验证; 这样就验证了接入AP的sdk合法性

2. 转发验证: 有两种方案

   方案一: 不做加密, 或由客户端和服务器间加密. 这种方法转发会高效很多, 但安全性较低. 客户端和服务器间加密做法是: AP接入成功后, 生成服务器密钥iv, 并通过/feedback向AS绑定uuid->(netid, iv). 这样客户端请求接入时会同时获得netid和iv.

   方案二: 每个AP接入点对其下属的sdk, 都通过了sdk_id对应到随机不同的加密密钥, 即每个sdk与AP之间数据加密方式都不相同; 这样相当于sdk<->AP, AP<->AP, AP<->sdk, 这三处各自加密, 安全性较高, 但是一次转发经过3次加解密, 效率较低.



### 九. 问题汇总

需要讨论的问题:

1. GetNetid()接口该向哪里获取uuid->netid的对应信息, AS服?
2. 选用的可靠传输协议是kcp?
3. 业务服务端调用sdk接入多个AP的设计
4. AP更新导致的问题和解决方案
5. 数据转发安全性设计讨论



需要调研的问题:

1. 长数据包分段与重组问题.