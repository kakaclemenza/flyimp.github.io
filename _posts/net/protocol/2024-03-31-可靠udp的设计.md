---
typora-root-url: ../../
---

为支持即时战斗游戏和即使语音视频, 业界会采用udp模式传输, 其中用到的关键技术大同小异, 大致如下:

> 本方案即为解决此类问题而生，方案采用FEC(Forward Error / Erasure  Correction ）前向纠错技术进行丢包恢复，由发送方进行FEC编码引入冗余包，接收方进行FEC解码，恢复丢失的数据包。对于包乱序和包重复和抖动，我们采用收端QOS处理，该QOS方案特点是在没有丢包的情况下，不引入任何系统延时，并且可以通过可控的丢包等待时延来适应不同的信道乱序程度。在FEC无法恢复的情况下，方案引入独创选择性实时重传NACK机制，在保障实时性的前提下大幅提高系统对连续丢包的抵抗力。本方案的另一个特色是支持根据网络传输信道状况自动调整FEC冗余度、QOS策略以及NACK机制，在抗丢包能力和带宽代价之间获得较好折中。
>
> 众多产品案例表明：采用FEC+QOS+NACK丢包重传+RTP的组合，能显著提升UDP传输的丢包、乱序抵抗力，为上层音视频服务提供有力保障。核心技术、行业领先，API接口非常简洁可以快速集成到现有系统。

udp实现可靠, 主要是两个手段:

* ARQ: 是一种按需重传的机制，发送者通过接受者的反馈得知有报文在传输过程中有丢失，就重传该报文。

  缺点：通信信道的利用率不高，也就是说信道还远远没有被数据流占满，需要接收方发送ACK，这样影响传输效率。可以想象，这种方式发送方肯定需要一个buffer来存储获取到的数据。重复发送数据包也会影响传输速度。可以称之为后向纠错。

* FEC: 是一种前向性纠错技术，发送方将要发送的数据加上一定的冗余纠错码一起发送，接收方则根据纠错码对接收到的数据进行差错检测，如发现差错，则由接收方进行纠错。

  特点：使用纠错码，单信道通信，发送方无需设置缓存。

* QOS: 其实拥塞控制就是一种QoS手段；QoS可以让网络管理者们控制网络带宽、延迟、抖动和数据丢失。QoS不是设备上的功能，也不仅是数据链路层的功能，QoS是一个端到端的系统体系，一个功能强大的QoS解决方案包括广泛的技术，并在整个网络中提供良好的扩展性和不依赖于任何介质的服务，并且具有系统功能检测能力。

  QoS技术的框架可以大致分为：**分类**、**入流量控制**、**排队**、**出流量控制**

  ref: 

  https://zhuanlan.zhihu.com/p/371546653

  http://www.h3c.com/cn/d_201104/922142_30005_0.htm



### ARQ设计思路

最近在搞这方面，分享点心得，不对请指正。
实时战斗游戏的话还是要用UDP了，因为TCP的特性，一旦丢包就会重发，阻塞住后续的数据包，因而可能会产生一个较大的瞬时延迟。

魔兽世界据说是用TCP。可能因为魔兽世界的游戏设计能很好的隐藏延迟，TCP用起来更简单些。

关于丢包检查，可以采用一个近似TCP的ack机制，可以给每个数据包都添加一个sequence ID，然后发送端就依次发送数据包，接收端收到数据包后就可以根据sequence ID来判断是否有丢包了。

接下来是重点，接收端需要发该sequenceID的ack给发送端，发送端才会知道这个包是否已经送达。但这是一笔不小的开销，而且，ack本身也有可能丢包。

可以这样，发送一个sequence ID的ack时，附加一个32bit的位序列，表示当前sequence ID之前的32个连续顺位的数据包是否已经送达，其实就是冗余的发送连续32个包的送达状态，如果bit为0说明这个包还没到，如果为1，说明已经收到了。这样一来，除非连续丢包30多次，ack是一定会送到的，这种几率已经非常小了。

相应的，在发送端设置一个超时机制，这个时间差不多比连续发30个ack的时间长一点，如果发送一个包后开始计时，达到超时还没有收到ack，这个包就丢失了。

但即使丢包了也不一定需要重发！是否需要重发，如何重发可以和游戏的逻辑结合起来，没有必要实现类似TCP那样的完全可靠的机制，毕竟战斗中的同步速率很高，丢一个一般也没啥事情。

语言组织能力欠佳，多包涵。



### FEC

**丢包率计算**

![capture](/img/net/fec_droprate_calculate.png)

`f(20,10,10%)=0.0089%` 表示10%丢包率的情况下`20+10个包中丢失10个以上的概率`为`0.0089%`。也就是说，网络本身的丢包率为`10%`，使用`-f20:10`参数后(`--mode 0`模式)，丢包率可以降低到`0.0089%

**算法选择**

目前基本看到的FEC编码算法的有parity, Reed-Solomon, Hamming, LDPC, XOR

* 最新的WebRTC版本中有实现了FLEXFEC
* 有一个OPENFEC开源项目如下编码实现   http://openfec.org/accueil.html