---
layout: post
title: 物理网络设备
category: net
tag: basic
---



### 总线, 集线器Hub --- 冲突域

## 一. 总线, 集线器Hub --- 冲突域

##### 冲突域的概念

```
a                b                 c 
|                |                 |
|--------------->|---------------->|
```

挖坟说下我的看法，大家看看我说的对不对。看周伟学长的书，对全双工为什么不用csma/cd很困惑，有和楼主一样的疑问，现在终于想明白了。下面说下我的看法：
​                  1.之所以不用csma/cd并不是因为能同时发送接收就不冲突了，楼主举的例子两个主机同时向一个主机发送还是要冲突。
​                  2.总线形以太网只能是半双工的，不可能实现全双工。
​                  3.用交换机连接的是星形网络，交换机分隔冲突域，可以工作在全双工下，两个主机通信就不会争用媒体，不存在冲突问题。
​                     对3我觉得可以分三点考虑：
​                    （1）所有交换机都可以分隔冲突域，每个端口全部带宽，即a->b c->d 不会冲突，但是a->c  b->a会冲突，因为半双工不能同时发送接受。
​                    （2）交换机工作在全双工，a->c b->a 不会冲突。
​                    （3）楼主提的情况，b->a c->a 无论何时都会冲突，因为网络传输是串行的，一个主机不能同时接收两个主机发的帧。
​                  综上，总线形不可能全双工，只能争用媒体，一定会有冲突，必须用csma/cd；用交换机连接的星形网络在全双工下，可以独立通信，不争用媒体，所以不会有冲突,不必用csma/cd。至于(3)这种情况, **b和c不可能绑定到统一根上行线上, 只要经过交换机等设备, 就会被妥善排队, 最终一个一个bit的发出**.
​        再说说无源有源。我觉得像书上画的那种总线网，用线直接连在一起，是无源的。用集线器、交换机、路由器连接的是星形结构，是有源的。只要能存储转发--交换机、路由器，就能分隔冲突域

可以结合这一题深入理解: https://blog.csdn.net/u011240016/article/details/52613941

总结下: 同一个方向(如下行)同一时刻只能传输一个bit.

##### 数据帧是怎么通过网卡发送出去的呢? 

首先, 我们要知道网络链路上传输的信号类型: 在链路上传输的信号分成两种：基带信号，宽带信号

* 基带信号（对应数字信号）：将数字信号0和1直接用两种不同的电压表示，然后传到数字信道上传输，这种传输叫做基带传输，通常用于局域网。
* 宽带信号（对应模拟信号）：借助频带传输，将链路容量分解为两个或多个信道，每个信道可以携带不同的信号 宽带中所有的信道可以同时互不干扰的发送信号。将基带信号调制后形成模拟信号，并在模拟信道上传输，而这种传输叫做宽带传输。
* 频带信号：它也是一种模拟信号，用数字信号对特定频率的**载波**进行调制，将其变成适合于传送的信号在传输（远距离传输 或 无线传输），不过频带传输和宽带传输有细微不同，宽带传输的子信道比频带传输的子信道更多。
* 数字数据通过**编码**可以变成数字信号，方式有：非归零码，曼彻斯特编码，差分曼彻斯特编码
* 数字数据通过**调制**可以变成模拟信号，方式有：幅移键控(ASK)，频移键控(FSK)，相移键控(PSK)，正交振幅调制(QAM)
* 模拟数据通过**编码**可以变成数字信号，步骤为：抽样、量化、编码
  

数据帧即0,1比特流, 在发送端网卡上会使用具体的数字编码和时钟同步方案编码为数字信号(比如下面看到的曼彻斯特编码), 然后发出. 发出的数据信号如果是通过电话线传输, 则还需要经过调制解调器数模转换变为模拟信号. 常见的网卡编码方式:

* 10BASE-T：网速10Mbit/s，使用2对双绞线，调制编码为**曼彻斯特编码**。
* 100BASE-TX：网速100Mbit/s，使用2对双绞线，调制编码为**MLT-3编码**
* 1000BASE-T：网速1000Mbit/s，使用4对双绞线，调制编码为**4D-PAM5编码**。

下面回顾下大学接触过的**曼彻斯特编码**(之前根本不知道是用来干嘛的, 只知道考试要考, 理论严重脱离实践). 它包括曼彻斯特编码和差分曼彻斯特编码, 差分曼彻斯特编码相比于曼彻斯特编码优点在于无需专门传递同步信号的线路, 差分曼彻斯特编码初始是0, 每一位中都自带同步时钟信息, 详细的回顾<信号与系统>课程. 

##### 半双工和全双工

半双工：在半双工模式下，通信双方都能发送和接受数据，但不能同时进行。当一台设备发送时，另一台只能接受，反之亦然。比如对讲机。

全双工：在全双工模式下，通信双方都能同时发送和接受数据，比如电话。**全双工模式下不会有冲突域**

两种模式都能支持双向数据传输。

以太网上的数据通信模式包括半双工和全双工两种，半双工模式下，共享物理介质的通信双方必需采用CSMA/CD机制来避免冲突。全双工模式下，通信双方可以同时实现双向通信，这种模式不会产生冲突，因此不须采用CSMA/CD机制。但同一链路上相连的两台设备必须保持一致。

@xiaofeng总结: 全双工和半双工是在物理上进行区分的概念, 也即物理设计上是否分隔了发送和接收这两个信道. 目前家用网线都是全双工的, 但是如果两端连接的设备有一端不支持全双工(可能是集线器, 也可能是不支持全双工的网卡), 最终的传输模式依然得按半双工考虑的.

再来讲讲集线器, 它其实就是中继器的升级版, 在加长传输距离的同时允许多端口接入. **但是它的通信模式属于半双工**! 无法隔离冲突域. 而交换机能够识别连接到交换机各端口上的网络设备的MAC地址, 可以实现对于冲突域的隔离, 属于全双工设备.

##### 以太网帧长度上下限由来
标准以太网帧长度下限为：64 字节
标准以太网帧长度上限为：1518 字节

最早的以太网工作方式：载波多路复用/冲突检测CSMA/CD，因为网络是共享的，即任何一个节点发送数据之前，先要侦听线路上是否有数据在传输，如果有，需要等待，如果线路可用，才可以发送。

假设A发出第一个bit位，到达B，而B也正在传输第一个bit位，于是产生冲突，冲突信号得让A在完成最后一个bit位之前到达A，这个一来一回的时间间隙slot time是57.6μs.

在10Mbps的网络中，在57.6μs的时间内，能够传输576个bit，所以要求以太网帧最小长度为576个bits，从而让最极端的碰撞都能够被检测到。这个576bit换算一下就是72个字节，去掉8个字节的前导符和帧开始符，以太网帧的最小长度为64字节。

如果说以太网帧的最小长度64byte是由CSMA/CD限制所致，那最大长度1500byte又是处于什么考虑的呢？

IP头total length为两个byte，理论上IP packet可以有65535 byte，加上Ethernet Frame头和尾，可以有65535 +14 + 4 = 65553 byte。如果在10Mbps以太网上，将会占用共享链路长达50ms,这将严重影响其它主机的通信，特别是对延迟敏感的应用是无法接受的。

由于线路质量差而引起的丢包，发生在大包的概率也比小包概率大得多，所以大包在丢包率较高的线路上不是一个好的选择。

但是如果选择一个比较小的长度，传输效率又不高，拿TCP应用来说，如果选择以太网长度为218byte，TCP payload = 218 – Ethernet Header -IP Header – TCP Header=218-18 – 20-20= 160 byte

那有效传输效率=160/218= **73%**

而如果以太网长度为1518，那有效传输效率=1460/1518=**96%**

通过比较，选择较大的帧长度，有效传输效率更高，而更大的帧长度同时也会造成上述的问题，于是最终选择一个折衷的长度：1518 byte ! 对应的IP packet 就是 1500 byte，这就是最大传输单元MTU的由来。

ref: https://www.huaijiujia.com/2018/07/25/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%AF%A6%E8%A7%A3-%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%E4%B9%8B%E4%BB%A5%E5%A4%AA%E7%BD%91/



## 二. 交换机/网桥 

交换机/网桥实现的是数据包的



## 三. 路由器

```
PC1 --- bridge1 --- router --- PC2
```

1． PC1与PC2通信时，在PC1电脑中，应用层产生数据交给传输层；传输层进行数据的分段，使数据的大小适合在网络上传递，根据应用层不同软件产生的数据，选择不同协议栈进行封装TCP或UDP,再进行不同服务端口号的封装（例：WWW 80 ,FTP 21），再传递给网络层；网络层在数据包头部进行封装源IP、目的IP，根据上层协议栈标识不同协议号，当IP包头封装TCP时协议号为6、UDP协议号为17，用来标识上层使用的协议，继续传递给数据链路层； 数据链路层在数据包头部进行帧的封装，封装源MAC、目的MAC,由于不知道目的MAC地址，会进行ARP的广播包，封装一个全F的类型字段为0X0806广播包，交付给物理层，物理层转换成电信号（bit流），发送到交换机；
2． 交换机接收后发现为ARP的广播包，进行其解封学习到PC1的MAC地址，继续封装并除接受端口以外的端口再次进行ARP的广播；
3． 路由器收到交换机发来的ARP广播，进行解封，查看到数据包中的类型字段为0X0806即ARP的广播包，进行回复，源MAC为路由（网关）的MAC,目的MAC为PC1的MAC，类型字段为0X0806，经过物理层将数据转换为电信号（bit流）发送给交换机；
4． 交换机收到后进行解封，学习到源MAC（路由器的MAC ），发现目的MAC已经存在自己的MAC表中，查看目的MAC对应的端口，并从对应的端口发送到PC1;
5． PC1接收数据包后进行解封，学习到路由器(网关)的MAC，在数据链路层将目的MAC封装为路由器（网关）的MAC, 类型字段为0X0800,并在数据帧尾部封装FCS,来校验数据的完整性，然后向下层传递给物理层，物理层把数据帧转换成电信号（bit流），发送到交换机；
（注：不同网段的通信，PC机先把数据传送到网关）
6． 交换机接收到数据包，查看到目的MAC已存在自己的MAC表中，根据自己MAC表中对应的端口发送出去；
7． 路由器接收到数据包后进行解封装，在数据包头部发现目的ip，便查找路由表条目中对应的端口，便对数据进行重写，由于不知道目的主机的MAC地址，路由器会发送ARP广播，PC2收到数据包进行解封，发现是ARP广播，类型字段为0X0806，
然后对其进行封装回复，源MAC为PC2的MAC，目的MAC为路由器的MAC，路由器收到后把PC2对应的MAC地址和端口记录在MAC表中，

8． -pc2接受到信息，便对数据进行解封装，发现目的ip是给自己的，然后继续解封装，然后把数据传送给应用程序qq。然后对路由回复，在传输层设源端口号为8000，目的端口号为4000，封装udp头部。在网络层将源ip设为192,。168.2.1，目的ip设为192.168.1.2，协议号为17，在数据链路层将源mac设为12个3，目的mac设为12个1，类型字段为0x0800，封装FCS，然后经物理层将数据转为bit流传给路由器，路由器再查找路由表，并对数据进行重写，从f0/0传送出去，交换机解封装，查找mac表，再对数据进行封装，从f0/0传送给pc1.通信完成。

ref: https://blog.csdn.net/tham_/article/details/42060511
ref: https://www.huaijiujia.com/2018/07/15/%e7%bd%91%e7%bb%9c%e5%8e%9f%e7%90%86-%e9%9b%86%e7%ba%bf%e5%99%a8%e7%bd%91%e6%a1%a5%e4%ba%a4%e6%8d%a2%e6%9c%ba%e8%b7%af%e7%94%b1%e5%99%a8%e7%bd%91%e5%85%b3%e8%af%a6%e8%a7%a3/

@xiaofeng 2019-05-30补充: 注意上面是路由器充当网关时的表项, 内网数据包出去时经过网关进行了数据包源ip地址+源port修改, 映射为网关的ip+网关的port, 再根据路由表查看是否可以直接转发或需要经过下一跳, 依此修改目标mac, 但不会修改目标ip, 不然就找不到目标了.

而如果路由器不充当网关, 则不会修改数据包源ip地址+源port, 只会根据路由表确定下一跳, 从而改写目标mac发出.

路由器的路由表由路由协议接替传输进行确定. 使用的路由算法如LS/DV等



## 四. 网卡ip地址与mac地址 --- 包接收过程

网络分层的原则：每一层独立于其他层完成自己的工作，而不需要相互依赖，上下层之间通过标准接口来互相通信，简单易用又具有扩展性。
以太网位于数据链路层，它是一种多路访问网络，换句话说：一个广播帧发出去，这个广播域里任何一台主机都可以接收。如果以太网没有属于自己的地址，难道都靠广播的方式传播出去？比如有台主机A与B，互相知道对方IP，如果没有MAC地址，它们之间的通信帧到达交换机（交换机属于二层设备），由于以太网头部没有MAC地址信息，交换机也只有从各个接口flooding 出去，结果就是这个广播域里的每台主机都会接收，由于网卡没有MAC地址，这些包会一直到达IP层，只有AB会接收，其它主机统统丢弃，这是对通信资源最大的浪费。所以以太网必须有自己的MAC地址，以方便在数据链路层来标示自己的唯一存在。

一般以太网通信时的目标地址有这么几种方式：

* 1）unicast
  A与B通信，A（10.1.1.1）知道B的IP为 10.1.1.2 ，需要通过ARP Request 广播的方式发送出去，B是广播域里的一员，所以也会接收到ARP，于是以ARP Reply的方式告诉A自己的MAC地址，于是A就知道B的MAC地址，并缓存在 ARP table 里。于是A与B就可以互相通信了。
* 2）multicast
  既然IP层有组播地址，比如 239.1.1.1，那二层也要有对应的MAC地址。这个MAC地址需要ARP吗？
  不需要！只需要计算就可以得到，计算方法如下：
  01:00:5e + 组播IP低23位 = 01:00:5e:01:01:01
  细心的童鞋一定会发现 224.1.1.1，225.1.1.1 …239.1.1.1 所对应的MAC 都为01:00:5e:01:01:01，这是历史原因造成的，因为申请组播MAC地址时，IANA只给了23位。
* 3）broadcast
  IP层的广播地址为：255.255.255.255
  以太网对应的MAC： FF:FF:FF:FF:FF:FF

一般链路层是多路访问的网络一定会有自己的标识符ID 或MAC地址，比如Frame Relay、ATM、Ethernet；而点对点通信，PPP、HDLC则不需要地址标识符。另外第二层的 MAC地址，第三层的IP地址，第四层的Port Number提供了三次筛子（filter ）的机会。

* 第一个筛子：目标mac如果不是本机的MAC地址、也没有匹配到组播MAC，也不是广播地址，则网卡拒绝接收；否则进入第二个筛子
* 第二个筛子：依据Unicast / Multicast / Broadcast 做出判断
  A Unicast
  A.1 匹配本地IP ，依据协议号提交给TCP/UDP，则进入第三个筛子
  A.2 没有匹配，查询路由表，找到下一跳，发送出去(**要开启ip_forward, 这就是网关的实现原理!**)
  B Multicast
  提交给已注册加入该multicast group 的进程
  C Broadcast
  提交给已注册接收broadcast 的进程
* 第三个筛子：依据Port Number 将数据提交给特定的进程

另外, 上面的**第一个筛子**涉及到的就是网卡的工作模式, 用于筛选mac:

* (1) 广播模式（Broad Cast Model）:它的物理地址（[MAC](https://www.baidu.com/s?wd=MAC&tn=24004469_oem_dg&rsv_dl=gh_pl_sl_csd)）地址是 0Xffffff 的帧为广播帧，工作在广播模式的网卡接收广播帧。

* (2) 多播传送（MultiCast Model）：多播传送地址作为目的物理地址的帧可以被组内的其它主机同时接收，而组外主机却接收不到。但是，如果将网卡设置为多播传送模式，它可以接收所有的多播传送帧，而不论它是不是组内成员。

* (3) 直接模式（Direct Model）:工作在直接模式下的网卡只接收目地址是自己 Mac地址的帧。

* (4) 混杂模式（Promiscuous Model）:工作在混杂模式下的网卡接收所有的流过网卡的帧，信包捕获程序就是在这种模式下运行的。**网卡的缺省工作模式包含广播模式和直接模式**，即它只接收广播帧和发给自己的帧。如果采用混杂模式，一个站点的网卡将接受同一网络内所有站点所发送的数据包这样就可以到达对于网络信息监视捕获的目的。linux下配置混杂模式:

  ```shell
  # 查看混杂模式, 如果开启了, 在flags字段会有PROMISC字样
  ifconfig eth1
  
  ifconfig eth1 promisc  #设置混杂模式
  ifconfig eth1 -promisc #取消混杂模式
  # 也可以通过C调用ioctl函数进行设置
  ```



## 五. 网络中间件设备: NAT, 防火墙

### 概念

防火墙（Firewall）：防火墙主要限制内网和公网的通讯，通常丢弃未经许可的数据包。防火墙会检测(但是不修改)试图进入内网数据包的IP地址和TCP/UDP端口信息。

网络地址转换器（NAT）：NAT不止检查进入数据包的头部，而且对其进行修改，从而实现同一内网中不同主机共用更少的公网IP（通常是一个）。NAT分以下几类:

* 基本NAT（Basic NAT）：基本NAT会将内网主机的IP地址唯一映射为一个公网IP，不改变其TCP/UDP端口号。基本NAT通常只有在当NAT有**公网IP池**的时候才有用。

* 网络地址-端口转换器（NAPT）：到目前为止最常见的即为NAPT，其检测并修改出入数据包的IP地址和端口号，从而允许多个内网主机同时共享一个公网IP地址。NAPT又细分以下两类:
  * 对称NAT（Symmetric NAT）: 对称NAT与锥形NAT正好相反，不在所有公网-内网对的会话中维持一个固定的端口绑定。其为每个新的会话开辟一个新的端口
  * 锥形NAT（Cone NAT）：在建立了一对（公网IP，公网端口）和（内网IP，内网端口）二元组的绑定之后，Cone NAT会重用这组绑定用于接下来该应用程序的所有会话（同一内网IP和端口），只要还有一个会话还是激活的。
    例如，假设客户端A建立了两个连续的对外会话，从相同的内部端点（10.0.0.1:1234）到两个不同的外部服务端S1和S2。Cone NAT只为两个会话映射了一个公网端点（155.99.25.11:62000），确保客户端端口的“身份”在地址转换的时候保持不变。由于基本NAT和防火墙都不改变数据包的端口号，因此这些类型的中间件也可以看作是退化的Cone NAT。
    Cone NAT根据NAT如何接收已经建立的（公网IP，公网端口）对的输入数据还可以细分为以下三类：
    * 1) 全锥形NAT（Full Cone NAT）: 在一个新会话建立了公网/内网端口绑定之后，全锥形NAT接下来会接受对应公网端口的所有数据，无论是来自哪个（公网）终端。全锥NAT有时候也被称为“混杂”NAT（promiscuous NAT）。
    * 2) 受限锥形NAT（Restricted Cone NAT）: 受限锥形NAT只会转发符合某个条件的输入数据包。条件为：外部（源）IP地址匹配内网主机之前发送一个或多个数据包的结点的IP地址。受限NAT通过限制输入数据包为一组“已知的”外部IP地址，有效地精简了防火墙的规则。
    * 3) 端口受限锥形NAT（Port-Restricted Cone NAT）: 端口受限锥形NAT也类似，只当外部数据包的IP地址和端口号都匹配内网主机发送过的地址和端口号时才进行转发。端口受限锥形NAT为内部结点提供了和对称NAT相同等级的保护，以隔离未关联的数据。

### P2P穿透NAT

根据客户端所处的NAT设备类型的不同，客户端之间进行P2P传输的方法也略有不同，这里介绍了现有的穿越中间件进行P2P通信的几种技术:

* 中继（Relaying）: 这是**最可靠**但也是**最低效**的一种P2P通信实现。其原理是通过一个有公网IP的服务器中间人对两个内网客户端的通信数据进行中继和**转发**(即应用层转发). 客户端A和客户端B不直接通信，而是先都与服务端S建立链接，然后再通过S和对方建立的通路来中继传递的数据。这钟方法的缺陷很明显，当链接的客户端变多之后，会显著增加服务器的负担，完全没体现出P2P的优势.
* 逆向链接（Connection reversal）: 这种方法在当两个端点中有一个不存在中间件的时候有效。例如，客户端A在NAT之后而客户端B拥有全局IP地址.
* UDP打洞（UDP hole punching）: 第三种P2P通信技术，被广泛采用的，名为“P2P打洞“, 当然也不有"TCP打洞", 这个下文有分析, 这里只关注UDP打洞。P2P打洞技术依赖于通常防火墙和cone NAT允许正当的P2P应用程序在中间件中打洞且与对方建立直接链接的特性。以下主要考虑两种常见的场景，以及应用程序如何设计去完美地处理这些情况。第一种场景代表了大多数情况，即两个需要直接链接的客户端处在两个不同的NAT之后；第二种场景是两个客户端在同一个NAT之后，但客户端自己并不需要知道。
  * 端点在不同的NAT之下: 假设客户端A和客户端B的地址都是内网地址，且在不同的NAT后面. A, B先和服务端S进行UDP连接, S就知道了A和B的公网ip:port, 假设A开始给B的公网地址发送UDP数据的同时，给服务器S发送一个中继请求，要求B开始给A的公网地址发送UDP信息。A往B的输出信息会导致NAT A打开一个A的内网地址与与B的外网地址之间的新通讯会话，B往A亦然。**一旦新的UDP会话在两个方向都打开之后**，客户端A和客户端B就能直接通讯，而无须再通过引导服务器S了.
  * 端点在相同的NAT之下: 两个客户端A和B正好在同一个NAT之后, 解决方案可以是: 当A和B最初通过S交换地址信息时，他们应该包含自身的IP地址和端口号（从自己看），同时也包含从服务器看的自己的地址和端口号。然后**客户端同时开始从对方已知的两个的地址中同时开始互相发送数据**，并使用**第一个成功**通信的地址作为对方地址。如果两个客户端在同一个NAT后，发送到对方内网地址的数据最有可能先到达，从而可以建立一条不经过NAT的通信链路；如果两个客户端在不同的NAT之后，发送给对方内网地址的数据包根本就到达不了对方，但仍然可以通过公网地址来建立通路。值得一提的是，虽然这些数据包通过某种方式验证，但是在不同NAT的情况下完全有可能会导致A往B发送的信息发送到其他A内网网段中无关的结点上去的。

注意: UDP打洞技术有一个主要的条件：**只有当**两个NAT都是Cone NAT（或者非NAT的防火墙）时才能工作, 否则还是只能通过"中继"的方式穿透NAT。因为其维持了一个给定的（内网IP，内网UDP）二元组和（公网IP， 公网UDP）二元组固定的端口绑定，只要该UDP端口还在使用中，就不会变化。如果像对称NAT一样，给每个新会话分配一个新的公网端口，就会导致UDP应用程序无法使用跟外部端点已经打通了的通信链路。由于Cone NAT是当今最广泛使用的，尽管有一小部分的对称NAT是不支持打洞的，UDP打洞技术也还是被广泛采纳应用.

**关于TCP打洞**: 因为TCP是基于连接的, TCP socket不允许在已经建立连接的端口上再进行监听和使用该本地端口，所以任何未经连接而发送的数据都会被丢弃，这导致在recv的时候是无法直接从peer端读取数据。
    其实这对UDP也一样，如果对UDP的socket进行了connect，其也会忽略连接之外的数据，详见`connect(2)`。
    所以，如果我们要进行TCP打洞，通常需要重用本地的endpoint来发起新的TCP连接，这样才能将已经打开的NAT利用起来。具体来说，则是要设置socket的
`SO_REUSEADDR`或`SO_REUSEPORT`属性，根据系统不同，其实现也不尽一致。一般来说，TCP打洞的步骤如下：

- A 发送 SYN 到 B （出口地址，下同），从而创建NAT A的一组映射
- B 发送 SYN 到 A， 创建NAT B的一组映射
- 根据时序不同，两个SYN中**有一个会被对方的NAT丢弃**，另一个成功通过NAT
- 通过NAT的SYN报文被其中一方收到，即返回SYNACK， 完成握手
- 至此，TCP的打洞成功，获得一个不依赖于服务器的链接

TCP打洞成功率远没有UDP打洞高, 原因有如下几点:

* [1] 有些NAT防火墙策略对TCP协议不是很友好
  有些NAT的防火墙策略不允许来路不明的外部向内网机器发起TCP连接。由于TCP是有连接的，NAT比较容易分清哪些是NAT    内网机器主动进行通信的外部节点，这样防火墙策略比较明确。而UDP是无连接的，没有连接来标明一个数据流，协议比较简单，这样NAT支持的比较多。

* [2] TCP协议本身
  由于TCP的TIME_WAIT状态引起，同一个NAT后面的其他主机发起的连接被误判。具体可以看下面的文章
  http://km.oa.com/group/25569/articles/show/246068

* [3] TCP协议的实现API
  因为标准的Berkeley sockets API是围绕C/S编程而设计的。这个API通过connect()允许一个TCP流套接字初始化一个向外的连接，通过listen()和 accept()监听一个外入的连接，一个套接字不能既用来监听又用来初始化向外的连接。更进一步讲， TCP套接字通常与本地主机上的TCP端口一一对应：一个套接字绑定到本地主机机上的某个端口后，另一个套接字就不能再绑定到该端口。然而TCP打洞要成功，需要一个本地的TCP端口既可以监听外入的连接，同时又可以发起多个向外的连接。幸运的是，所有主流的操作系统都支持一个特殊的socket选项SO_REUSEADDR，它运行应用程序绑定多个设置了该选项的套接字到同一端口。BSD系统引入了SO_REUSEPORT选项来控制端口重用，从而把端口重用和地址重用相分离。在这样的系统中，两个选项都需要被设置。尽管如此，要进行TCP打洞需要进行TCP三次握手的同时打开，但是有些TCP/IP的实现，可能不支持这种同时打开的情况，这样也就无法建立TCP连接了。