---
layout: post
title: tcp伪造数据包测试或攻击
category: net
typora-root-url: ../..
---

## 测试

本篇我们来探究下如何自己构造数据包, 完成tcp虚拟数据包的高效收发. 主要的目的是用于在局域网实现高并发量的虚拟网络包访问测试, 并发量取决于CPU对数据包的构造速度, 排除内核协议栈其他因素的影响.

构造过程中利用到了arp欺骗技术, 另外本文也凸显处syn泛洪的做法. 目前基于scapy

### 一. 同网段虚拟包发送

```python
fake_arp.pdst = "192.168.140.102"
fake_arp.psrc = "192.168.140.180"
fake_arp.hwsrc = "45:00:00:28:00:fc"
fake_arp.display()

#@xiaofeng: 注意arp包要在三层发包, 原因需要结合协议栈深究
send(fake_arp)

fake_pkt = Ether(src="45:00:00:28:00:fc", dst="08:00:27:67:7a:dd")/IP(src="192.168.140.180", dst="192.168.140.102")/TCP(sport=13579, dport=5223,flags="S")
#@xiaofeng构造二层包, 注意需要指定正确的网卡接口
sendp(fake_pkt, iface="vboxnet0")
```

linux下arp手动绑定:
arp -f /etc/ip-mac

### 二. 不同网段虚拟包发送

```python
fake_arp.pdst = "192.168.140.102"
fake_arp.psrc = "171.17.17.37"
fake_arp.hwsrc = "45:00:00:28:00:fc"
fake_arp.display()

send(fake_arp)

fake_pkt = Ether(src="45:00:00:28:00:fc", dst="08:00:27:67:7a:dd")/IP(src="171.17.17.37", dst="192.168.140.102")/TCP(sport=13579, dport=5223,flags="S")
sendp(fake_pkt, iface="vboxnet0")
```
会出现192.168.140.102收到包, 但是不回复包的情况. arp -n发现171.17.17.37和mac的对应关系是绑定到eth1网卡上的. 而回包目标地址为171.17.17.37, 在本地路由决断中会走默认网关eth0出去, 不会索引到171.17.17.37对应的mac地址, 于是就会发起arp请求. 但是本地网络不会响应这个arp请求, 所以最终回复包无法正确构建, 丢弃!

要解决这个问题, 可以选择把默认网关置由eth1出的某个地址(已验证), 或者指定171.17.17.37的host或net走eth1出区.
```
# 目标机192.168.140.102设置
route del default gw 10.0.2.2
route add default gw 192.168.140.1

#或者
route add -net 171.17.17.37/24 dev eth1
```



### 三. 单纯使用:
pkt = IP(src="192.168.140.180", dst="192.168.140.102")/TCP(sport=13579, dport=5223,flags="S")
send(pkt)
为什么对端收到包, 却不回复包.

这个原因和第二点一样, 虽然通过路由决策判断到192.168.140.180走eth1网卡, 但是arp缓存中没有对应mac, 所以发起arp请求. 由于192.168.140.180是我们虚构的ip, 本网段中不存在, 所以arp解析失败, 最终回复包无法正确构建, 丢弃!



## 攻击

### tcp syn泛洪



### tcp重置攻击

预备知识：

* 滑动窗口：**接收方的滑动窗口大小是指发送方无需等待确认应答，可以持续发送数据的最大值。**TCP 规范规定，接收方应该忽略任何序列号在接收窗口之外的数据。例如，如果接收方确认了所有序列号在 `15,000` 以下的字节，且接收窗口大小为 `30,000`，那么接下来接收方只能接收序列号范围在 `15,000 ~ 45,000` 之间的数据。**如果一个报文段的部分数据在窗口内，另一部分数据在窗口外，那么窗口内的数据将被接收确认，窗口外的数据将被丢弃**。**注意：这里忽略了选择确认选项，再强调一遍！**
  * 滑动窗口大小是以字节为单位，所以一个报文可能部分被接收
  * TCP 连接双方会在建立连接的初始握手阶段通告对方自己窗口的大小，后续还可以动态调整。TCP 缓冲区大的服务器可能会声明一个大窗口，以便最大限度提高吞吐量
  * 如果考虑SACK：TCP 头部包含了多个选项，其中有一个选择确认选项（`SACK`），如果使用该选项，那么当接收方收到了某个范围内的字节而不是连续的字节时，就会发送 `SACK` 告知对方。例如，只收到了字节 `1000~3000` 和 `4000~5000`，但没有收到 `3001~3999`。
* seq和ack：seq代表本报文的需要，ack代表已收到的报文
  * 注意：**ack也代表对端下一个报文的seq编号！！！**

对于 TCP 重置报文段来说，接收方接收序号要求：

* 2010 年之前：只要seq在滑动窗口内即可，否则直接丢包
* 2010年后：要求接收到的报文seq等于本端发送的ack（即预期对端发送的下一个报文seq编号），否则，会回复`challenge ACK`，告诉发送方重置报文段的序列号是错误的，并告之正确的序列号

实施攻击：

* 如果攻击者能截获链接报文，则可以直接利用ack信息构造重置报文。比如：GFW
* 如果攻击者无法解惑报文，需要盲目TCP重置攻击。在 2010 年之前 TCP 的原始版本中，攻击者只需要猜对接收窗口内的随便哪一个序列号即可，一般只需发送几万个报文段就能成功。采取额外限制的措施后，攻击者需要发送数以百万计的报文段才有可能猜对序列号，这几乎是很难成功的。